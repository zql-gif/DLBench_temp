[
    {
        "sql_id": "duckdb_1_33",
        "database_name": "duckdb_1_33",
        "source_dialect": "postgresql",
        "target_dialect": "duckdb",
        "source_query": "INSERT INTO clstr_tst (a, b, c, d) VALUES (32, 6, 'seis', repeat('xyzzy', 10000)); -- REPEAT",
        "target_query": "INSERT INTO clstr_tst (a, b, c, d) VALUES (32, 6, 'seis', REPEAT('xyzzy', 10000));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `clstr_tst`\nColumns:\n(a, integer, PRI)\n(b, integer, )\n(c, text, )\n(d, text, )\n"
        ],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_10_2",
        "database_name": "duckdb_10_2",
        "source_dialect": "postgresql",
        "target_dialect": "duckdb",
        "source_query": "INSERT INTO tidrangescan SELECT i,repeat('x', 100) FROM generate_series(1,200) AS s(i); -- REPEAT, GENERATE_SERIES",
        "target_query": "INSERT INTO tidrangescan SELECT i,repeat('x', 100) FROM generate_series(1,200) AS s(i);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT",
            "GENERATE_SERIES"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            },
            {
                "expression": "generate_series(start, stop [, step])",
                "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
                "examples": [
                    "SELECT generate_series(1, 5);",
                    "SELECT generate_series(3, 9, 2);",
                    "SELECT generate_series(10, 6, -2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            },
            {
                "expression": "generate_series(start, stop [, step])",
                "description": "Returns a numeric series from start to stop, with an optional step, fully compatible with PostgreSQL.",
                "examples": [
                    "SELECT * FROM generate_series(1, 5);",
                    "SELECT * FROM generate_series(3, 9, 2);",
                    "SELECT * FROM generate_series(10, 6, -2);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `tidrangescan`\nColumns:\n(id, integer, )\n(data, text, )\n"
        ],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_12_0",
        "database_name": "duckdb_12_0",
        "source_dialect": "postgresql",
        "target_dialect": "duckdb",
        "source_query": "SELECT generate_series(1, 3); -- GENERATE_SERIES",
        "target_query": "SELECT * FROM generate_series(1, 3);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "GENERATE_SERIES"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "generate_series(start, stop [, step])",
                "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
                "examples": [
                    "SELECT generate_series(1, 5);",
                    "SELECT generate_series(3, 9, 2);",
                    "SELECT generate_series(10, 6, -2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "generate_series(start, stop [, step])",
                "description": "Returns a numeric series from start to stop, with an optional step, fully compatible with PostgreSQL.",
                "examples": [
                    "SELECT * FROM generate_series(1, 5);",
                    "SELECT * FROM generate_series(3, 9, 2);",
                    "SELECT * FROM generate_series(10, 6, -2);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_12_1",
        "database_name": "duckdb_12_1",
        "source_dialect": "postgresql",
        "target_dialect": "duckdb",
        "source_query": "SELECT generate_series(1, 3) AS val1, generate_series(3,5) AS val2; -- GENERATE_SERIES",
        "target_query": "SELECT * FROM generate_series(1, 3) AS t1(val1), generate_series(3, 5) AS t2(val2);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "GENERATE_SERIES"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "generate_series(start, stop [, step])",
                "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
                "examples": [
                    "SELECT generate_series(1, 5);",
                    "SELECT generate_series(3, 9, 2);",
                    "SELECT generate_series(10, 6, -2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "generate_series(start, stop [, step])",
                "description": "Returns a numeric series from start to stop, with an optional step, fully compatible with PostgreSQL.",
                "examples": [
                    "SELECT * FROM generate_series(1, 5);",
                    "SELECT * FROM generate_series(3, 9, 2);",
                    "SELECT * FROM generate_series(10, 6, -2);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_12_2",
        "database_name": "duckdb_12_2",
        "source_dialect": "postgresql",
        "target_dialect": "duckdb",
        "source_query": "SELECT generate_series(1, 2) AS val1, generate_series(1,4) AS val2; -- GENERATE_SERIES",
        "target_query": "SELECT * FROM generate_series(1, 2) AS t1(val1), generate_series(1, 4) AS t2(val2);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "GENERATE_SERIES"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "generate_series(start, stop [, step])",
                "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
                "examples": [
                    "SELECT generate_series(1, 5);",
                    "SELECT generate_series(3, 9, 2);",
                    "SELECT generate_series(10, 6, -2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "generate_series(start, stop [, step])",
                "description": "Returns a numeric series from start to stop, with an optional step, fully compatible with PostgreSQL.",
                "examples": [
                    "SELECT * FROM generate_series(1, 5);",
                    "SELECT * FROM generate_series(3, 9, 2);",
                    "SELECT * FROM generate_series(10, 6, -2);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_2_2",
        "database_name": "duckdb_2_2",
        "source_dialect": "postgresql",
        "target_dialect": "duckdb",
        "source_query": "INSERT INTO cmdata VALUES(repeat('1234567890', 1000)); -- REPEAT",
        "target_query": "INSERT INTO cmdata VALUES(repeat('1234567890', 1000));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `cmdata`\nColumns:\n(f1, text, )\n"
        ],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_2_6",
        "database_name": "duckdb_2_6",
        "source_dialect": "postgresql",
        "target_dialect": "duckdb",
        "source_query": "INSERT INTO cmdata1 VALUES(repeat('1234567890', 1004)); -- REPEAT",
        "target_query": "INSERT INTO cmdata1 VALUES(repeat('1234567890', 1004));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `cmdata1`\nColumns:\n(f1, text, )\n"
        ],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_3_3",
        "database_name": "duckdb_3_3",
        "source_dialect": "postgresql",
        "target_dialect": "duckdb",
        "source_query": "INSERT INTO delete_test (id, a, b) VALUES (2, 50, repeat('x', 10000)); -- REPEAT",
        "target_query": "INSERT INTO delete_test (id, a, b) VALUES (2, 50, REPEAT('x', 10000));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `delete_test`\nColumns:\n(id, integer, PRI)\n(a, integer, )\n(b, text, )\n"
        ],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_4_0",
        "database_name": "duckdb_4_0",
        "source_dialect": "postgresql",
        "target_dialect": "duckdb",
        "source_query": "SELECT current_timestamp = NOW(); -- NOW",
        "target_query": "SELECT current_timestamp = CURRENT_TIMESTAMP;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "NOW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "In PostgreSQL, CURRENT_TIMESTAMP is used to retrieve the current date and time, equivalent to NOW() in MySQL and MariaDB.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "DuckDB also uses CURRENT_TIMESTAMP to get the current date and time, similar to PostgreSQL and MonetDB.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_5_0",
        "database_name": "duckdb_5_0",
        "source_dialect": "postgresql",
        "target_dialect": "duckdb",
        "source_query": "select current_schemas(false); -- CURRENT_SCHEMAS",
        "target_query": "SELECT current_schemas(FALSE);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CURRENT_SCHEMAS"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "current_schemas(include_implicit boolean)",
                "description": "Returns a text array of schema names in the current search path. The boolean parameter controls whether implicit schemas such as pg_catalog are included.",
                "examples": [
                    "SELECT current_schemas(false);",
                    "SELECT current_schemas(true);",
                    "SELECT unnest(current_schemas(false));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "current_schemas(include_implicit BOOLEAN)",
                "description": "Returns an array of schema names in the current search path for the session. The boolean parameter controls inclusion of implicit schemas.",
                "examples": [
                    "SELECT current_schemas(FALSE);",
                    "SELECT current_schemas(TRUE);",
                    "SELECT UNNEST(current_schemas(FALSE));"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_6_2",
        "database_name": "duckdb_6_2",
        "source_dialect": "postgresql",
        "target_dialect": "duckdb",
        "source_query": "create table simple1 as select generate_series(1, 200) AS id; -- GENERATE_SERIES",
        "target_query": "create table simple1 as select generate_series(1, 200) AS id;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "GENERATE_SERIES"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "generate_series(start, stop [, step])",
                "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
                "examples": [
                    "SELECT generate_series(1, 5);",
                    "SELECT generate_series(3, 9, 2);",
                    "SELECT generate_series(10, 6, -2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "generate_series(start, stop [, step])",
                "description": "Returns a numeric series from start to stop, with an optional step, fully compatible with PostgreSQL.",
                "examples": [
                    "SELECT * FROM generate_series(1, 5);",
                    "SELECT * FROM generate_series(3, 9, 2);",
                    "SELECT * FROM generate_series(10, 6, -2);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_6_5",
        "database_name": "duckdb_6_5",
        "source_dialect": "postgresql",
        "target_dialect": "duckdb",
        "source_query": "create table bigger_than_it_looks as select generate_series(1, 200) as id; -- GENERATE_SERIES",
        "target_query": "create table bigger_than_it_looks as select generate_series(1, 200) as id;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "GENERATE_SERIES"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "generate_series(start, stop [, step])",
                "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
                "examples": [
                    "SELECT generate_series(1, 5);",
                    "SELECT generate_series(3, 9, 2);",
                    "SELECT generate_series(10, 6, -2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "generate_series(start, stop [, step])",
                "description": "Returns a numeric series from start to stop, with an optional step, fully compatible with PostgreSQL.",
                "examples": [
                    "SELECT * FROM generate_series(1, 5);",
                    "SELECT * FROM generate_series(3, 9, 2);",
                    "SELECT * FROM generate_series(10, 6, -2);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `simple1`\nColumns:\n(id, integer, )\n"
        ],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_6_10",
        "database_name": "duckdb_6_10",
        "source_dialect": "postgresql",
        "target_dialect": "duckdb",
        "source_query": "insert into extremely_skewed select 42 as id, 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'from generate_series(1, 200); -- GENERATE_SERIES",
        "target_query": "insert into extremely_skewed select 42 as id, 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' from generate_series(1, 200);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "GENERATE_SERIES"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "generate_series(start, stop [, step])",
                "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
                "examples": [
                    "SELECT generate_series(1, 5);",
                    "SELECT generate_series(3, 9, 2);",
                    "SELECT generate_series(10, 6, -2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "generate_series(start, stop [, step])",
                "description": "Returns a numeric series from start to stop, with an optional step, fully compatible with PostgreSQL.",
                "examples": [
                    "SELECT * FROM generate_series(1, 5);",
                    "SELECT * FROM generate_series(3, 9, 2);",
                    "SELECT * FROM generate_series(10, 6, -2);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `bigger_than_it_looks`\nColumns:\n(id, integer, )\n",
            "Table: `extremely_skewed`\nColumns:\n(id, integer, )\n(t, text, )\n",
            "Table: `simple1`\nColumns:\n(id, integer, )\n"
        ],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_6_12",
        "database_name": "duckdb_6_12",
        "source_dialect": "postgresql",
        "target_dialect": "duckdb",
        "source_query": "create table wide as select generate_series(1, 2) as id, rpad('', 320000, 'x') as t; -- GENERATE_SERIES, RPAD",
        "target_query": "create table wide as select generate_series(1, 2) as id, rpad('', 320000, 'x') as t;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "GENERATE_SERIES",
            "RPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "generate_series(start, stop [, step])",
                "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
                "examples": [
                    "SELECT generate_series(1, 5);",
                    "SELECT generate_series(3, 9, 2);",
                    "SELECT generate_series(10, 6, -2);"
                ]
            },
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "PostgreSQL doesn't have a native RPAD, but can simulate it.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123::text, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "generate_series(start, stop [, step])",
                "description": "Returns a numeric series from start to stop, with an optional step, fully compatible with PostgreSQL.",
                "examples": [
                    "SELECT * FROM generate_series(1, 5);",
                    "SELECT * FROM generate_series(3, 9, 2);",
                    "SELECT * FROM generate_series(10, 6, -2);"
                ]
            },
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "DuckDB supports RPAD for string padding.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123::TEXT, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `bigger_than_it_looks`\nColumns:\n(id, integer, )\n",
            "Table: `extremely_skewed`\nColumns:\n(id, integer, )\n(t, text, )\n",
            "Table: `simple1`\nColumns:\n(id, integer, )\n"
        ],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_6_14",
        "database_name": "duckdb_6_14",
        "source_dialect": "postgresql",
        "target_dialect": "duckdb",
        "source_query": "create table join_foo as select generate_series(1, 3) as id, 'xxxxx'::text as t; -- GENERATE_SERIES",
        "target_query": "create table join_foo as select generate_series(1, 3) as id, 'xxxxx'::text as t;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "GENERATE_SERIES"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "generate_series(start, stop [, step])",
                "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
                "examples": [
                    "SELECT generate_series(1, 5);",
                    "SELECT generate_series(3, 9, 2);",
                    "SELECT generate_series(10, 6, -2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "generate_series(start, stop [, step])",
                "description": "Returns a numeric series from start to stop, with an optional step, fully compatible with PostgreSQL.",
                "examples": [
                    "SELECT * FROM generate_series(1, 5);",
                    "SELECT * FROM generate_series(3, 9, 2);",
                    "SELECT * FROM generate_series(10, 6, -2);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `bigger_than_it_looks`\nColumns:\n(id, integer, )\n",
            "Table: `extremely_skewed`\nColumns:\n(id, integer, )\n(t, text, )\n",
            "Table: `simple1`\nColumns:\n(id, integer, )\n",
            "Table: `wide`\nColumns:\n(id, integer, )\n(t, text, )\n"
        ],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_6_16",
        "database_name": "duckdb_6_16",
        "source_dialect": "postgresql",
        "target_dialect": "duckdb",
        "source_query": "create table join_bar as select generate_series(1, 10000) as id, 'xxxxx'::text as t; -- GENERATE_SERIES",
        "target_query": "create table join_bar as select generate_series(1, 10000) as id, 'xxxxx'::text as t;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "GENERATE_SERIES"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "generate_series(start, stop [, step])",
                "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
                "examples": [
                    "SELECT generate_series(1, 5);",
                    "SELECT generate_series(3, 9, 2);",
                    "SELECT generate_series(10, 6, -2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "generate_series(start, stop [, step])",
                "description": "Returns a numeric series from start to stop, with an optional step, fully compatible with PostgreSQL.",
                "examples": [
                    "SELECT * FROM generate_series(1, 5);",
                    "SELECT * FROM generate_series(3, 9, 2);",
                    "SELECT * FROM generate_series(10, 6, -2);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `bigger_than_it_looks`\nColumns:\n(id, integer, )\n",
            "Table: `extremely_skewed`\nColumns:\n(id, integer, )\n(t, text, )\n",
            "Table: `join_foo`\nColumns:\n(id, integer, )\n(t, text, )\n",
            "Table: `simple1`\nColumns:\n(id, integer, )\n",
            "Table: `wide`\nColumns:\n(id, integer, )\n(t, text, )\n"
        ],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_7_2",
        "database_name": "duckdb_7_2",
        "source_dialect": "postgresql",
        "target_dialect": "duckdb",
        "source_query": "INSERT INTO pagg_tab SELECT i % 20, i % 30, to_char(i % 12, 'FM0000'), i % 30 FROM generate_series(0, 2999) i; -- TO_CHAR, GENERATE_SERIES",
        "target_query": "WITH series AS (SELECT generate_series AS i FROM generate_series(0, 2999)) INSERT INTO pagg_tab SELECT i % 20, i % 30, lpad(CAST(i % 12 AS VARCHAR), 4, '0'), i % 30 FROM series;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TO_CHAR",
            "GENERATE_SERIES"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "to_char(numeric, 'FM0000')",
                "description": "Formats a number as a zero-padded 4-digit string without leading spaces.",
                "examples": [
                    "SELECT to_char(5, 'FM0000');   -- 0005",
                    "SELECT to_char(123, 'FM0000'); -- 0123",
                    "SELECT to_char(0, 'FM0000');   -- 0000"
                ]
            },
            {
                "expression": "generate_series(start, stop [, step])",
                "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
                "examples": [
                    "SELECT generate_series(1, 5);",
                    "SELECT generate_series(3, 9, 2);",
                    "SELECT generate_series(10, 6, -2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "lpad(CAST(value AS VARCHAR), 4, '0')",
                "description": "Pads number with zeros to 4-digit string using lpad.",
                "examples": [
                    "SELECT lpad(CAST(5 AS VARCHAR), 4, '0');",
                    "SELECT lpad(CAST(123 AS VARCHAR), 4, '0');",
                    "SELECT lpad(CAST(0 AS VARCHAR), 4, '0');"
                ]
            },
            {
                "expression": "generate_series(start, stop [, step])",
                "description": "Returns a numeric series from start to stop, with an optional step, fully compatible with PostgreSQL.",
                "examples": [
                    "SELECT * FROM generate_series(1, 5);",
                    "SELECT * FROM generate_series(3, 9, 2);",
                    "SELECT * FROM generate_series(10, 6, -2);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `pagg_tab`\nColumns:\n(a, integer, )\n(b, integer, )\n(c, text, )\n(d, integer, )\n"
        ],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_7_7",
        "database_name": "duckdb_7_7",
        "source_dialect": "postgresql",
        "target_dialect": "duckdb",
        "source_query": "INSERT INTO pagg_tab_ml SELECT i % 30, i % 10, to_char(i % 4, 'FM0000') FROM generate_series(0, 29999) i; -- TO_CHAR",
        "target_query": "WITH series AS (SELECT generate_series AS i FROM generate_series(0, 29999)) INSERT INTO pagg_tab_ml SELECT i % 30, i % 10, lpad(CAST(i % 4 AS VARCHAR), 4, '0') FROM series;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TO_CHAR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "to_char(numeric, 'FM0000')",
                "description": "Formats a number as a zero-padded 4-digit string without leading spaces.",
                "examples": [
                    "SELECT to_char(5, 'FM0000');   -- 0005",
                    "SELECT to_char(123, 'FM0000'); -- 0123",
                    "SELECT to_char(0, 'FM0000');   -- 0000"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "lpad(CAST(value AS VARCHAR), 4, '0')",
                "description": "Pads number with zeros to 4-digit string using lpad.",
                "examples": [
                    "SELECT lpad(CAST(5 AS VARCHAR), 4, '0');",
                    "SELECT lpad(CAST(123 AS VARCHAR), 4, '0');",
                    "SELECT lpad(CAST(0 AS VARCHAR), 4, '0');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `pagg_tab_ml`\nColumns:\n(a, integer, )\n(b, integer, )\n(c, text, )\n"
        ],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_7_9",
        "database_name": "duckdb_7_9",
        "source_dialect": "postgresql",
        "target_dialect": "duckdb",
        "source_query": "SELECT a, sum(b), array_agg(distinct c), count(*) FROM pagg_tab_ml GROUP BY a HAVING avg(b) < 3 ORDER BY 1, 2, 3; -- ARRAY_AGG",
        "target_query": "SELECT a, sum(b), array_agg(distinct c), count(*) FROM pagg_tab_ml GROUP BY a HAVING avg(b) < 3 ORDER BY 1, 2, 3;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ARRAY_AGG"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "ARRAY_AGG(expression [DISTINCT])",
                "description": "Aggregate function that returns an array of all input values, optionally removing duplicates if DISTINCT is specified.",
                "examples": [
                    "SELECT ARRAY_AGG(DISTINCT x) FROM (VALUES (1), (2), (1), (3)) AS t(x);",
                    "SELECT id, ARRAY_AGG(value) FROM my_table GROUP BY id;",
                    "SELECT ARRAY_AGG(DISTINCT LOWER(name)) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "ARRAY_AGG(expression [DISTINCT])",
                "description": "Aggregate function that collects input values into an array, optionally removing duplicates with DISTINCT. Fully equivalent to PostgreSQL's ARRAY_AGG.",
                "examples": [
                    "SELECT ARRAY_AGG(DISTINCT x) FROM (VALUES (1), (2), (1), (3)) AS t(x);",
                    "SELECT id, ARRAY_AGG(value) FROM my_table GROUP BY id;",
                    "SELECT ARRAY_AGG(DISTINCT LOWER(name)) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `pagg_tab_ml`\nColumns:\n(a, integer, )\n(b, integer, )\n(c, text, )\n"
        ],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_8_2",
        "database_name": "duckdb_8_2",
        "source_dialect": "postgresql",
        "target_dialect": "duckdb",
        "source_query": "INSERT INTO prt1 SELECT i, i % 25, to_char(i, 'FM0000') FROM generate_series(0, 599) i WHERE i % 2 = 0; -- TO_CHAR, GENERATE_SERIES",
        "target_query": "WITH series AS (SELECT generate_series AS i FROM generate_series(0, 599)) INSERT INTO prt1 SELECT i, i % 25, lpad(CAST(i AS VARCHAR), 4, '0') FROM series WHERE i % 2 = 0;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TO_CHAR",
            "GENERATE_SERIES"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "to_char(numeric, 'FM0000')",
                "description": "Formats a number as a zero-padded 4-digit string without leading spaces.",
                "examples": [
                    "SELECT to_char(5, 'FM0000');   -- 0005",
                    "SELECT to_char(123, 'FM0000'); -- 0123",
                    "SELECT to_char(0, 'FM0000');   -- 0000"
                ]
            },
            {
                "expression": "generate_series(start, stop [, step])",
                "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
                "examples": [
                    "SELECT generate_series(1, 5);",
                    "SELECT generate_series(3, 9, 2);",
                    "SELECT generate_series(10, 6, -2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "lpad(CAST(value AS VARCHAR), 4, '0')",
                "description": "Pads number with zeros to 4-digit string using lpad.",
                "examples": [
                    "SELECT lpad(CAST(5 AS VARCHAR), 4, '0');",
                    "SELECT lpad(CAST(123 AS VARCHAR), 4, '0');",
                    "SELECT lpad(CAST(0 AS VARCHAR), 4, '0');"
                ]
            },
            {
                "expression": "generate_series(start, stop [, step])",
                "description": "Returns a numeric series from start to stop, with an optional step, fully compatible with PostgreSQL.",
                "examples": [
                    "SELECT * FROM generate_series(1, 5);",
                    "SELECT * FROM generate_series(3, 9, 2);",
                    "SELECT * FROM generate_series(10, 6, -2);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `prt1`\nColumns:\n(a, integer, )\n(b, integer, )\n(c, character varying, )\n"
        ],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_8_7",
        "database_name": "duckdb_8_7",
        "source_dialect": "postgresql",
        "target_dialect": "duckdb",
        "source_query": "INSERT INTO prt2 SELECT i % 25, i, to_char(i, 'FM0000') FROM generate_series(0, 599) i WHERE i % 3 = 0; -- TO_CHAR, GENERATE_SERIES",
        "target_query": "WITH series AS (SELECT generate_series AS i FROM generate_series(0, 599)) INSERT INTO prt2 SELECT i % 25, i, lpad(CAST(i AS VARCHAR), 4, '0') FROM series WHERE i % 3 = 0;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TO_CHAR",
            "GENERATE_SERIES"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "to_char(numeric, 'FM0000')",
                "description": "Formats a number as a zero-padded 4-digit string without leading spaces.",
                "examples": [
                    "SELECT to_char(5, 'FM0000');   -- 0005",
                    "SELECT to_char(123, 'FM0000'); -- 0123",
                    "SELECT to_char(0, 'FM0000');   -- 0000"
                ]
            },
            {
                "expression": "generate_series(start, stop [, step])",
                "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
                "examples": [
                    "SELECT generate_series(1, 5);",
                    "SELECT generate_series(3, 9, 2);",
                    "SELECT generate_series(10, 6, -2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "lpad(CAST(value AS VARCHAR), 4, '0')",
                "description": "Pads number with zeros to 4-digit string using lpad.",
                "examples": [
                    "SELECT lpad(CAST(5 AS VARCHAR), 4, '0');",
                    "SELECT lpad(CAST(123 AS VARCHAR), 4, '0');",
                    "SELECT lpad(CAST(0 AS VARCHAR), 4, '0');"
                ]
            },
            {
                "expression": "generate_series(start, stop [, step])",
                "description": "Returns a numeric series from start to stop, with an optional step, fully compatible with PostgreSQL.",
                "examples": [
                    "SELECT * FROM generate_series(1, 5);",
                    "SELECT * FROM generate_series(3, 9, 2);",
                    "SELECT * FROM generate_series(10, 6, -2);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `prt2`\nColumns:\n(a, integer, )\n(b, integer, )\n(c, character varying, )\n"
        ],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_9_2",
        "database_name": "duckdb_9_2",
        "source_dialect": "postgresql",
        "target_dialect": "duckdb",
        "source_query": "SELECT nextval('seq3'); -- NEXTVAL",
        "target_query": "SELECT nextval('seq3');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "NEXTVAL"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "nextval('sequence_name')",
                "description": "Returns the next value from a named sequence and increments the counter atomically.",
                "examples": [
                    "SELECT nextval('my_seq');",
                    "SELECT nextval('my_seq') + 5;",
                    "SELECT nextval('my_seq') * 2;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "nextval('sequence_name')",
                "description": "Returns the next value from a named sequence, compatible with PostgreSQL syntax.",
                "examples": [
                    "SELECT nextval('my_seq');",
                    "SELECT nextval('my_seq') + 5;",
                    "SELECT nextval('my_seq') * 2;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    }
]