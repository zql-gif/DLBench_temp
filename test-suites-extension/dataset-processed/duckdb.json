[
    {
        "sql_id": "duckdb_1_6",
        "database_name": "duckdb_1_6",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT * FROM t0 WHERE (a, b) IN (ROW(1, 10)); -- ROW",
        "target_query": "SELECT * FROM t0 WHERE (a, b) IN (ROW(1, 10));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t0`\nColumns:\n(a, int, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t0`\nColumns:\n(a, INTEGER, )\n(b, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_1_7",
        "database_name": "duckdb_1_7",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT * FROM t0 WHERE (a, b) IN (VALUES ROW(1, 10), ROW(2, 20)); -- ROW",
        "target_query": "SELECT * FROM t0 WHERE (a, b) IN (ROW(1, 10), ROW(2, 20));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t0`\nColumns:\n(a, int, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t0`\nColumns:\n(a, INTEGER, )\n(b, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_1_8",
        "database_name": "duckdb_1_8",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT * FROM t0 WHERE (a, b) NOT IN (VALUES ROW(1, 10)); -- ROW",
        "target_query": "SELECT * FROM t0 WHERE (a, b) NOT IN (ROW(1, 10));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t0`\nColumns:\n(a, int, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t0`\nColumns:\n(a, INTEGER, )\n(b, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_1_9",
        "database_name": "duckdb_1_9",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT * FROM t0 WHERE (a, b) NOT IN (VALUES ROW(1, 10), ROW(2, 20)); -- ROW",
        "target_query": "SELECT * FROM t0 WHERE (a, b) NOT IN (ROW(1, 10), ROW(2, 20));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t0`\nColumns:\n(a, int, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t0`\nColumns:\n(a, INTEGER, )\n(b, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_100_2",
        "database_name": "duckdb_100_2",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "INSERT INTO t1 (ts) VALUES (Unix_timestamp('2002-10-27 01:00')); -- UNIX_TIMESTAMP",
        "target_query": "INSERT INTO t1 (ts) VALUES (EXTRACT(EPOCH FROM TIMESTAMP '2002-10-27 01:00'));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNIX_TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(ts, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(ts, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_100_3",
        "database_name": "duckdb_100_3",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "INSERT INTO t1 (ts) VALUES (Unix_timestamp('2002-10-27 02:00')); -- UNIX_TIMESTAMP",
        "target_query": "INSERT INTO t1 (ts) VALUES (EXTRACT(EPOCH FROM TIMESTAMP '2002-10-27 02:00'));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNIX_TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(ts, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(ts, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_100_4",
        "database_name": "duckdb_100_4",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "INSERT INTO t1 (ts) VALUES (Unix_timestamp('2002-10-27 03:00')); -- UNIX_TIMESTAMP",
        "target_query": "INSERT INTO t1 (ts) VALUES (EXTRACT(EPOCH FROM TIMESTAMP '2002-10-27 03:00'));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNIX_TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(ts, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(ts, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_100_5",
        "database_name": "duckdb_100_5",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT ts,from_unixtime(ts) FROM t1; -- FROM_UNIXTIME",
        "target_query": "SELECT ts, TO_TIMESTAMP(ts) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "FROM_UNIXTIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
                "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
                "examples": [
                    "SELECT FROM_UNIXTIME(1672531200);",
                    "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
                    "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_TIMESTAMP(unix_timestamp)",
                "description": "Converts a Unix timestamp (seconds since epoch) to a TIMESTAMP value.",
                "examples": [
                    "SELECT TO_TIMESTAMP(1672531200);",
                    "SELECT TO_TIMESTAMP(1672531200.789);",
                    "SELECT id, TO_TIMESTAMP(event_time) AS event_ts FROM events;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(ts, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(ts, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_100_7",
        "database_name": "duckdb_100_7",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT TIMESTAMP( '2001-01-01 00:00:00' ); -- TIMESTAMP",
        "target_query": "SELECT TIMESTAMP '2001-01-01 00:00:00';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMESTAMP('2023-06-15', '10:30:45')",
                "description": "TIMESTAMP is a function in MySQL that combines a date and a time string into a TIMESTAMP value, handling timezone-aware and non-timezone-aware date-time strings.",
                "examples": [
                    "SELECT TIMESTAMP('2023-06-15', '10:30:45');",
                    "SELECT TIMESTAMP('2023-06-15 10:30:45+02:00');",
                    "SELECT TIMESTAMP('2023-06-15 10:30:45') > TIMESTAMP('2023-06-14 10:30:45');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TIMESTAMP '2023-06-15 10:30:45'",
                "description": "DuckDB supports the TIMESTAMP function to handle date-time strings as TIMESTAMP values.",
                "examples": [
                    "SELECT TIMESTAMP '2023-06-15 10:30:45';",
                    "SELECT TIMESTAMP '2023-06-15 10:30:45+02:00';",
                    "SELECT TIMESTAMP '2023-06-15 10:30:45' > TIMESTAMP '2023-06-14 10:30:45';"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_100_8",
        "database_name": "duckdb_100_8",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT TO_DAYS( '2001-01-01 00:00:00' ); -- TO_DAYS",
        "target_query": "SELECT DATEDIFF('day', DATE '1970-01-01', DATE '2001-01-01 00:00:00') + 719528;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TO_DAYS"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TO_DAYS(date)",
                "description": "Returns the number of days since 0000-01-01 for a given date.",
                "examples": [
                    "SELECT TO_DAYS('2024-05-07');",
                    "SELECT TO_DAYS(CURDATE());",
                    "SELECT TO_DAYS('1999-12-31 23:59:59');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "DATEDIFF('day', DATE '1970-01-01', date) + 719528",
                "description": "Computes the number of days since 0000-01-01 by offsetting from 1970-01-01.",
                "examples": [
                    "SELECT DATEDIFF('day', DATE '1970-01-01', DATE '2024-05-07') + 719528;",
                    "SELECT DATEDIFF('day', DATE '1970-01-01', CURRENT_DATE) + 719528;",
                    "SELECT DATEDIFF('day', DATE '1970-01-01', DATE '1999-12-31') + 719528;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_100_9",
        "database_name": "duckdb_100_9",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT TO_DAYS( '2001-01-01 00:00:00' ); -- TO_DAYS",
        "target_query": "SELECT DATEDIFF('day', DATE '1970-01-01', DATE '2001-01-01 00:00:00') + 719528;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TO_DAYS"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TO_DAYS(date)",
                "description": "Returns the number of days since 0000-01-01 for a given date.",
                "examples": [
                    "SELECT TO_DAYS('2024-05-07');",
                    "SELECT TO_DAYS(CURDATE());",
                    "SELECT TO_DAYS('1999-12-31 23:59:59');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "DATEDIFF('day', DATE '1970-01-01', date) + 719528",
                "description": "Computes the number of days since 0000-01-01 by offsetting from 1970-01-01.",
                "examples": [
                    "SELECT DATEDIFF('day', DATE '1970-01-01', DATE '2024-05-07') + 719528;",
                    "SELECT DATEDIFF('day', DATE '1970-01-01', CURRENT_DATE) + 719528;",
                    "SELECT DATEDIFF('day', DATE '1970-01-01', DATE '1999-12-31') + 719528;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_100_10",
        "database_name": "duckdb_100_10",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT DATEDIFF( '2007-12-31 23:59:59', '2007-12-30  00:00:00' ); -- DATEDIFF",
        "target_query": "SELECT DATE_DIFF('day', DATE '2007-12-30 00:00:00', DATE '2007-12-31 23:59:59');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "DATEDIFF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATEDIFF(date1, date2)",
                "description": "Returns the number of days between two date or datetime expressions (date1 - date2), ignoring time part.",
                "examples": [
                    "SELECT DATEDIFF('2025-12-31', '2025-12-01');",
                    "SELECT DATEDIFF('2025-01-01', '2024-12-31');",
                    "SELECT DATEDIFF(NULL, '2025-01-01');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "DATE_DIFF('day', date2, date1)",
                "description": "Computes the number of days between two dates as an integer by specifying the 'day' unit.",
                "examples": [
                    "SELECT DATE_DIFF('day', DATE '2025-12-01', DATE '2025-12-31');",
                    "SELECT DATE_DIFF('day', DATE '2024-12-31', DATE '2025-01-01');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_100_11",
        "database_name": "duckdb_100_11",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT TIMEDIFF( '2000:01:01 00:00:00','2000:01:01 00:00:00' ); -- TIMEDIFF",
        "target_query": "SELECT TIMESTAMP '2000-01-01 00:00:00' - TIMESTAMP '2000-01-01 00:00:00';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIMEDIFF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMEDIFF('12:00:00', '10:00:00')",
                "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
                "examples": [
                    "SELECT TIMEDIFF('12:00:00', '10:00:00');",
                    "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
                    "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TIMESTAMP '2023-06-15 12:00:00' - TIMESTAMP '2023-06-15 10:00:00'",
                "description": "DuckDB supports direct subtraction between timestamps to calculate the difference, returning the result as an interval.",
                "examples": [
                    "SELECT TIMESTAMP '2023-06-15 12:00:00' - TIMESTAMP '2023-06-15 10:00:00';",
                    "SELECT CURRENT_TIMESTAMP - TIMESTAMP '2023-06-15 10:00:00';",
                    "SELECT TIMESTAMP '2023-06-15 12:00:00' - TIMESTAMP '2023-06-15 10:00:00';"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_100_12",
        "database_name": "duckdb_100_12",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT DATE_FORMAT( '2009-10-10 23:59:59', '%W %M %Y' ); -- DATE_FORMAT",
        "target_query": "SELECT STRFTIME(TIMESTAMP '2009-10-10 23:59:59', '%W %M %Y');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "DATE_FORMAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_FORMAT(date_expr, format_str)",
                "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
                "examples": [
                    "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
                    "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "STRFTIME(date_expr, format_str)",
                "description": "Formats a date/time value using SQLite-compatible strftime format specifiers.",
                "examples": [
                    "SELECT STRFTIME('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT STRFTIME(CURRENT_TIMESTAMP, '%Y-%m-%d %H:%M:%S');",
                    "SELECT STRFTIME('2023-01-15 12:00:00', '%d-%m-%Y');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_100_13",
        "database_name": "duckdb_100_13",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT TIME( '2003-12-31 23:59:59' ); -- TIME",
        "target_query": "SELECT STRFTIME(TIMESTAMP '2003-12-31 23:59:59', '%H:%M:%S');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
                "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
                "examples": [
                    "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
                    "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
                    "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "strftime(format, datetime_expr)",
                "description": "DuckDB does not have a native TIME type, so operations involving just hours, minutes, and seconds must be done on full DateTime values. The `strftime` function can be used to extract or format time from a complete `TIMESTAMP` value. If a time value does not include year information (e.g., '14:16:00'), a default year (e.g., '1970-01-01') must be added to ensure it forms a valid `TIMESTAMP`. This is necessary to perform the time-based operations correctly.",
                "examples": [
                    "SELECT strftime('%H:%M:%S', CAST(CURRENT_TIMESTAMP AS TIMESTAMP)); -- Returns the current time formatted as 'HH:MM:SS'.",
                    "SELECT strftime('%H:%M:%S', CAST(CURRENT_TIMESTAMP + INTERVAL '1 hour' AS TIMESTAMP)); -- Adds 1 hour to the time, returning 'HH:MM:SS'.",
                    "SELECT strftime('%H:%M:%S.%f', CAST(CONCAT('1970-01-01 ', '14:16:00') AS TIMESTAMP)); -- Returns '14:16:00.000000' with fractional seconds by concatenating time with a default date."
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_100_14",
        "database_name": "duckdb_100_14",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT TIMESTAMP( '2003-12-31 23:59:59', '12:00:00' ); -- TIMESTAMP",
        "target_query": "SELECT TIMESTAMP '2003-12-31 23:59:59' + INTERVAL '12:00:00';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMESTAMP('2023-06-15', '10:30:45')",
                "description": "TIMESTAMP is a function in MySQL that combines a date and a time string into a TIMESTAMP value, handling timezone-aware and non-timezone-aware date-time strings.",
                "examples": [
                    "SELECT TIMESTAMP('2023-06-15', '10:30:45');",
                    "SELECT TIMESTAMP('2023-06-15 10:30:45+02:00');",
                    "SELECT TIMESTAMP('2023-06-15 10:30:45') > TIMESTAMP('2023-06-14 10:30:45');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TIMESTAMP '2023-06-15 10:30:45'",
                "description": "DuckDB supports the TIMESTAMP function to handle date-time strings as TIMESTAMP values.",
                "examples": [
                    "SELECT TIMESTAMP '2023-06-15 10:30:45';",
                    "SELECT TIMESTAMP '2023-06-15 10:30:45+02:00';",
                    "SELECT TIMESTAMP '2023-06-15 10:30:45' > TIMESTAMP '2023-06-14 10:30:45';"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_100_15",
        "database_name": "duckdb_100_15",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT TIMESTAMPADD(MINUTE, 1, '2003-01-02 23:59:59' ); -- TIMESTAMPADD",
        "target_query": "SELECT TIMESTAMP '2003-01-02 23:59:59' + INTERVAL '1 minute';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIMESTAMPADD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMESTAMPADD(unit, interval, datetime_expr)",
                "description": "Adds a time interval to a date or timestamp expression using the specified unit.",
                "examples": [
                    "SELECT TIMESTAMPADD(DAY, 2, '2023-01-01');",
                    "SELECT TIMESTAMPADD(MINUTE, -5, '2023-05-10 12:00:00');",
                    "SELECT TIMESTAMPADD(YEAR, 1, '2020-06-15');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "datetime_expr + INTERVAL 'n unit'",
                "description": "Performs datetime arithmetic by adding a specified time interval using INTERVAL syntax.",
                "examples": [
                    "SELECT DATE '2023-01-01' + INTERVAL '2 day';",
                    "SELECT TIMESTAMP '2023-05-10 12:00:00' + INTERVAL '-5 minute';",
                    "SELECT DATE '2020-06-15' + INTERVAL '1 year';"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_100_16",
        "database_name": "duckdb_100_16",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT TIMESTAMPDIFF(MONTH, '2003-02-01 23:59:59', '2003-05-01' ); -- TIMESTAMPDIFF",
        "target_query": "SELECT DATEDIFF('month', DATE '2003-02-01 23:59:59', DATE '2003-05-01');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TIMESTAMPDIFF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMESTAMPDIFF(unit, datetime1, datetime2)",
                "description": "Returns the difference between two datetime values in the specified unit.",
                "examples": [
                    "SELECT TIMESTAMPDIFF(YEAR, '2001-01-01', '2005-01-01');  -- 4",
                    "SELECT TIMESTAMPDIFF(MONTH, '2020-01-01', '2020-03-01');  -- 2",
                    "SELECT TIMESTAMPDIFF(DAY, '2020-01-01', '2020-01-31');    -- 30"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "DATEDIFF(unit, datetime1, datetime2)",
                "description": "Computes the difference between two dates in the specified unit. The result is positive if the first date is earlier than the second date.",
                "examples": [
                    "SELECT DATEDIFF('year', DATE '2001-01-01', DATE '2005-01-01');  -- 4",
                    "SELECT DATEDIFF('month', DATE '2020-01-01', DATE '2020-03-01');  -- 2",
                    "SELECT DATEDIFF('day', DATE '2020-01-01', DATE '2020-01-31');    -- 30"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_100_17",
        "database_name": "duckdb_100_17",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT TO_SECONDS( '2009-11-29 23:59:59' ); -- TO_SECONDS",
        "target_query": "SELECT epoch(TIMESTAMP '2009-11-29 23:59:59') + 62167219200;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TO_SECONDS"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TO_SECONDS(datetime_expr)",
                "description": "Returns the number of seconds since year 0 to the given datetime.",
                "examples": [
                    "SELECT TO_SECONDS('2000-01-01 00:00:00');",
                    "SELECT TO_SECONDS(NOW());",
                    "SELECT TO_SECONDS(NULL);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "epoch(ts) + 62167219200",
                "description": "Converts timestamp to Unix epoch time and adds the number of seconds between year 0 and 1970.",
                "examples": [
                    "SELECT epoch(TIMESTAMP '2020-12-31 12:00:00') + 62167219200;",
                    "SELECT epoch(CURRENT_TIMESTAMP) + 62167219200;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_100_18",
        "database_name": "duckdb_100_18",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT UNIX_TIMESTAMP( '2015-11-13 23:59:59' ); -- UNIX_TIMESTAMP",
        "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNIX_TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_101_3",
        "database_name": "duckdb_101_3",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select hex(s1) from t1; -- HEX",
        "target_query": "select hex(s1) from t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts numeric or string values into their hexadecimal string representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(s1, blob, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(s1, BLOB, )\n"
        ]
    },
    {
        "sql_id": "duckdb_101_7",
        "database_name": "duckdb_101_7",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select length(concat('*',s1,'*',s2,'*')) from t1; -- LENGTH, CONCAT",
        "target_query": "select length(concat('*',s1,'*',s2,'*')) from t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH",
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            },
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "length(str)",
                "description": "Returns the number of bytes in the input string.",
                "examples": [
                    "SELECT length('abc');"
                ]
            },
            {
                "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
                "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT 'Year: ' || 2025;",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(s1, blob, )\n(s2, blob, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(s1, BLOB, )\n(s2, BLOB, )\n"
        ]
    },
    {
        "sql_id": "duckdb_101_11",
        "database_name": "duckdb_101_11",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select hex(s1),s2 from t1 order by s1,s2; -- HEX",
        "target_query": "select hex(s1),s2 from t1 order by s1,s2;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts numeric or string values into their hexadecimal string representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(s1, blob, )\n(s2, varchar(1), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(s1, BLOB, )\n(s2, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_101_12",
        "database_name": "duckdb_101_12",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select convert(123456789,unsigned); -- CONVERT",
        "target_query": "select CAST(123456789 AS BIGINT);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONVERT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONVERT(expression USING charset)",
                "description": "Converts data types or changes the character set.",
                "examples": [
                    "SELECT CONVERT('Hello World' USING utf8);",
                    "SELECT CONVERT(1234, CHAR);",
                    "SELECT CONVERT(column_name USING latin1) FROM my_table;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CAST(expression AS target_type)",
                "description": "DuckDB uses CAST for type conversion. No direct equivalent for CONVERT TO CHARACTER SET.",
                "examples": [
                    "SELECT CAST('2021-12-31' AS DATE);",
                    "SELECT CAST(1234 AS VARCHAR);",
                    "SELECT CAST(column_name AS VARCHAR) FROM my_table;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(s1, blob, )\n(s2, varchar(1), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(s1, BLOB, )\n(s2, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_102_2",
        "database_name": "duckdb_102_2",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "INSERT INTO t1 VALUES (DATE(NOW()), 1); -- DATE, NOW",
        "target_query": "INSERT INTO t1 VALUES (CAST(CURRENT_TIMESTAMP AS DATE), 1);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "DATE",
            "NOW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE()",
                "description": "In MySQL, the DATE function extracts the date part from a DATETIME or TIMESTAMP value.",
                "examples": [
                    "SELECT DATE('2023-05-01 12:34:56') AS result;",
                    "SELECT DATE(NOW()) AS current_date_result;",
                    "SELECT DATE(CAST('2023-05-01' AS DATETIME)) AS date_from_datetime;"
                ]
            },
            {
                "expression": "NOW()",
                "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
                "examples": [
                    "SELECT NOW();",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (NOW());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CAST()",
                "description": "DuckDB supports the CAST function to extract a DATE from a TIMESTAMP or DATETIME.",
                "examples": [
                    "SELECT CAST('2023-05-01 12:34:56' AS DATE) AS result;",
                    "SELECT CURRENT_DATE AS current_date_result;",
                    "SELECT CAST('2023-05-01' AS DATE) AS date_from_datetime;"
                ]
            },
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "DuckDB also uses CURRENT_TIMESTAMP to get the current date and time, similar to PostgreSQL and MonetDB.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, date, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, DATE, )\n(b, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_102_3",
        "database_name": "duckdb_102_3",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT COUNT(*) FROM t1 WHERE a = NOW(); -- COUNT, NOW",
        "target_query": "SELECT COUNT(*) FROM t1 WHERE a = CURRENT_TIMESTAMP;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "COUNT",
            "NOW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "COUNT()",
                "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
                "examples": [
                    "EXPLAIN FORMAT=TREE SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
                    "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
                    "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
                ]
            },
            {
                "expression": "NOW()",
                "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
                "examples": [
                    "SELECT NOW();",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (NOW());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COUNT()",
                "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
                "examples": [
                    "EXPLAIN SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
                    "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
                    "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
                ]
            },
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "DuckDB also uses CURRENT_TIMESTAMP to get the current date and time, similar to PostgreSQL and MonetDB.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, date, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, DATE, )\n(b, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_102_4",
        "database_name": "duckdb_102_4",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "INSERT INTO t1 VALUES (DATE(NOW()), 2); -- DATE, NOW",
        "target_query": "INSERT INTO t1 VALUES (CAST(CURRENT_TIMESTAMP AS DATE), 2);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "DATE",
            "NOW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE()",
                "description": "In MySQL, the DATE function extracts the date part from a DATETIME or TIMESTAMP value.",
                "examples": [
                    "SELECT DATE('2023-05-01 12:34:56') AS result;",
                    "SELECT DATE(NOW()) AS current_date_result;",
                    "SELECT DATE(CAST('2023-05-01' AS DATETIME)) AS date_from_datetime;"
                ]
            },
            {
                "expression": "NOW()",
                "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
                "examples": [
                    "SELECT NOW();",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (NOW());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CAST()",
                "description": "DuckDB supports the CAST function to extract a DATE from a TIMESTAMP or DATETIME.",
                "examples": [
                    "SELECT CAST('2023-05-01 12:34:56' AS DATE) AS result;",
                    "SELECT CURRENT_DATE AS current_date_result;",
                    "SELECT CAST('2023-05-01' AS DATE) AS date_from_datetime;"
                ]
            },
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "DuckDB also uses CURRENT_TIMESTAMP to get the current date and time, similar to PostgreSQL and MonetDB.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, date, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, DATE, )\n(b, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_102_5",
        "database_name": "duckdb_102_5",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT COUNT(*) FROM t1 WHERE a = NOW(); -- COUNT, NOW",
        "target_query": "SELECT COUNT(*) FROM t1 WHERE a = CURRENT_TIMESTAMP;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "COUNT",
            "NOW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "COUNT()",
                "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
                "examples": [
                    "EXPLAIN FORMAT=TREE SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
                    "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
                    "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
                ]
            },
            {
                "expression": "NOW()",
                "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
                "examples": [
                    "SELECT NOW();",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (NOW());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COUNT()",
                "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
                "examples": [
                    "EXPLAIN SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
                    "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
                    "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
                ]
            },
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "DuckDB also uses CURRENT_TIMESTAMP to get the current date and time, similar to PostgreSQL and MonetDB.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, date, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, DATE, )\n(b, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_102_6",
        "database_name": "duckdb_102_6",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT COUNT(*) FROM t1 WHERE a = NOW() AND b = 1; -- COUNT, NOW",
        "target_query": "SELECT COUNT(*) FROM t1 WHERE a = CURRENT_TIMESTAMP AND b = 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "COUNT",
            "NOW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "COUNT()",
                "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
                "examples": [
                    "EXPLAIN FORMAT=TREE SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
                    "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
                    "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
                ]
            },
            {
                "expression": "NOW()",
                "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
                "examples": [
                    "SELECT NOW();",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (NOW());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COUNT()",
                "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
                "examples": [
                    "EXPLAIN SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
                    "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
                    "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
                ]
            },
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "DuckDB also uses CURRENT_TIMESTAMP to get the current date and time, similar to PostgreSQL and MonetDB.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, date, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, DATE, )\n(b, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_102_8",
        "database_name": "duckdb_102_8",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "CREATE TABLE t1 SELECT curdate() AS f1; -- CURDATE",
        "target_query": "CREATE TABLE t1 AS SELECT CURRENT_DATE AS f1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CURDATE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CURDATE()",
                "description": "Returns the current date without the time component.",
                "examples": [
                    "SELECT CURDATE();",
                    "SELECT CONCAT('Today\\'s date is: ', CURDATE());",
                    "SELECT 1 WHERE CURDATE() = CURDATE();"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CURRENT_DATE",
                "description": "Returns the current date without the time component, equivalent to MySQL's CURDATE().",
                "examples": [
                    "SELECT CURRENT_DATE;",
                    "SELECT CONCAT('Today''s date is: ', CURRENT_DATE);",
                    "SELECT 1 WHERE CURRENT_DATE = CURRENT_DATE;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(f1, date, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(f1, DATE, )\n"
        ]
    },
    {
        "sql_id": "duckdb_102_9",
        "database_name": "duckdb_102_9",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT hour(f1), minute(f1), second(f1) FROM t1; -- HOUR, MINUTE, SECOND",
        "target_query": "SELECT EXTRACT(HOUR FROM f1), MINUTE(f1), EXTRACT(SECOND FROM f1) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HOUR",
            "MINUTE",
            "SECOND"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HOUR(expr)",
                "description": "Extracts the hour (0\u201323) from a time or datetime expression.",
                "examples": [
                    "SELECT HOUR('18:45:30');",
                    "SELECT HOUR('2023-10-01 08:15:00');",
                    "SELECT HOUR(CURRENT_TIMESTAMP);"
                ]
            },
            {
                "expression": "MINUTE()",
                "description": "Extracts the minute part from a time or datetime value.",
                "examples": [
                    "SELECT MINUTE('12:34:56');",
                    "SELECT MINUTE('2025-01-01 10:30:00');",
                    "SELECT MINUTE(NULL);"
                ]
            },
            {
                "expression": "SECOND(time)",
                "description": "Extracts the second part from a TIME, DATETIME, or TIMESTAMP value.",
                "examples": [
                    "SELECT SECOND('10:11:12');",
                    "SELECT SECOND(4.99999999991e0);",
                    "SELECT SECOND(CAST('2007-07-19' AS DATE));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(HOUR FROM expr)",
                "description": "Extracts the hour from a timestamp or time value.",
                "examples": [
                    "SELECT EXTRACT(HOUR FROM TIME '18:45:30');",
                    "SELECT EXTRACT(HOUR FROM TIMESTAMP '2023-10-01 08:15:00');",
                    "SELECT EXTRACT(HOUR FROM CURRENT_TIMESTAMP);"
                ]
            },
            {
                "expression": "MINUTE()",
                "description": "Extracts the minute part from a time or timestamp value.",
                "examples": [
                    "SELECT MINUTE('2025-01-01 12:34:56'::TIMESTAMP);",
                    "SELECT MINUTE('12:34:56'::TIME);",
                    "SELECT MINUTE(NULL::TIMESTAMP);"
                ]
            },
            {
                "expression": "EXTRACT(SECOND FROM time)",
                "description": "Extracts the second part from a TIME, INTERVAL, or timestamp value.",
                "examples": [
                    "SELECT EXTRACT(SECOND FROM TIME '10:11:12');",
                    "SELECT EXTRACT(SECOND FROM INTERVAL '4.99999999991');",
                    "SELECT EXTRACT(SECOND FROM CAST('2007-07-19' AS DATE));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(f1, date, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(f1, DATE, )\n"
        ]
    },
    {
        "sql_id": "duckdb_102_17",
        "database_name": "duckdb_102_17",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT 1 FROM (SELECT LAST_DAY('0')) a; -- LAST_DAY",
        "target_query": "SELECT 1 FROM (SELECT last_day(date '0')) a;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LAST_DAY"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LAST_DAY()",
                "description": "Returns the last day of the month for a given date or datetime expression.",
                "examples": [
                    "SELECT LAST_DAY('2000-02-05') AS last_day_1;",
                    "SELECT LAST_DAY(CURRENT_DATE) AS last_day_2;",
                    "SELECT LAST_DAY('2025-05-17 15:32:00') AS last_day_3;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "last_day(date)",
                "description": "Returns the last day of the month for a given date or timestamp expression, matching MySQL's LAST_DAY behavior.",
                "examples": [
                    "SELECT last_day(date '2000-02-05');",
                    "SELECT last_day(CURRENT_DATE);",
                    "SELECT last_day(timestamp '2025-05-17 15:32:00');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_102_18",
        "database_name": "duckdb_102_18",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT 1 FROM (SELECT MAKEDATE(2011,0)) a; -- MAKEDATE",
        "target_query": "SELECT 1 FROM (SELECT date '2011-01-01' + (0 - 1) * INTERVAL '1 day') a;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "MAKEDATE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MAKEDATE(year, day_of_year)",
                "description": "Returns a date from the given year and day of the year.",
                "examples": [
                    "SELECT MAKEDATE(2009, 1) AS first_day_of_year;",
                    "SELECT MAKEDATE(2025, 100) AS specific_date;",
                    "SELECT MAKEDATE(2020, 366) AS last_day_of_year;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "date 'year-01-01' + (day_of_year - 1) * INTERVAL '1 day'",
                "description": "Returns a date from the given year and day of the year by adding intervals.",
                "examples": [
                    "SELECT date '2009-01-01' + (1 - 1) * INTERVAL '1 day' AS first_day_of_year;",
                    "SELECT date '2025-01-01' + (100 - 1) * INTERVAL '1 day' AS specific_date;",
                    "SELECT date '2020-01-01' + (366 - 1) * INTERVAL '1 day' AS last_day_of_year;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_2_2",
        "database_name": "duckdb_2_2",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "WITH recursive qn as (select 1 as n, cast('x' as char(100)) as un union all select 1+n, concat(un,'x') from qn where n<10) select * from qn; -- CONCAT",
        "target_query": "WITH recursive qn as (select 1 as n, cast('x' as char(100)) as un union all select 1+n, un || 'x' from qn where n<10) select * from qn; -- CONCAT",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
                "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT 'Year: ' || 2025;",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t`\nColumns:\n(c, char(3), )\n(vc, varchar(3), )\n(b, binary(3), )\n(vb, varbinary(3), )\n"
        ],
        "target_related_schemas": [
            "Table: `t`\nColumns:\n(c, VARCHAR, )\n(vc, VARCHAR, )\n(b, BLOB, )\n(vb, BLOB, )\n"
        ]
    },
    {
        "sql_id": "duckdb_3_2",
        "database_name": "duckdb_3_2",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT IF (COUNT(*) > 0, \"YES\", \"NO\") AS \"IMPLICIT COMMIT\" FROM trans; -- IF",
        "target_query": "SELECT CASE WHEN COUNT(*) > 0 THEN 'YES' ELSE 'NO' END AS \"IMPLICIT COMMIT\" FROM trans; -- IF",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "DuckDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It allows you to return different values based on a given condition.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `trans`\nColumns:\n(a, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `trans`\nColumns:\n(a, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_39_3",
        "database_name": "duckdb_39_3",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT IF( a = 1, a, a ) AS b FROM t1 ORDER BY field( b + 1, 1 ); -- IF, FIELD",
        "target_query": "SELECT CASE WHEN a = 1 THEN a ELSE a END AS b FROM t1 ORDER BY COALESCE(array_position(ARRAY[1], b + 1), 0);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IF",
            "FIELD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            },
            {
                "expression": "FIELD(val, val1, val2, ..., valN)",
                "description": "Returns the index (1-based) of the first value in the list that is equal to 'val'. Returns 0 if no match is found.",
                "examples": [
                    "SELECT FIELD('c', 'a', 'b', 'c') AS result;",
                    "SELECT FIELD('x', 'a', 'b', 'c') AS result;",
                    "SELECT FIELD('b', 'b', 'b', 'b') AS result;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "DuckDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It allows you to return different values based on a given condition.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            },
            {
                "expression": "COALESCE(array_position(ARRAY[val1, val2, ..., valN], val), 0)",
                "description": "Returns the index (1-based) of 'val' in the array. Returns 0 if not found, emulating MySQL FIELD().",
                "examples": [
                    "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'c'), 0) AS result;",
                    "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'x'), 0) AS result;",
                    "SELECT COALESCE(array_position(ARRAY['b', 'b', 'b'], 'b'), 0) AS result;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_39_4",
        "database_name": "duckdb_39_4",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT IF( a = 1, a, a ) AS b FROM t1 ORDER BY field( b, 1 ); -- IF, FIELD",
        "target_query": "SELECT CASE WHEN a = 1 THEN a ELSE a END AS b FROM t1 ORDER BY COALESCE(array_position(ARRAY[1], b), 0);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IF",
            "FIELD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            },
            {
                "expression": "FIELD(val, val1, val2, ..., valN)",
                "description": "Returns the index (1-based) of the first value in the list that is equal to 'val'. Returns 0 if no match is found.",
                "examples": [
                    "SELECT FIELD('c', 'a', 'b', 'c') AS result;",
                    "SELECT FIELD('x', 'a', 'b', 'c') AS result;",
                    "SELECT FIELD('b', 'b', 'b', 'b') AS result;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "DuckDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It allows you to return different values based on a given condition.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            },
            {
                "expression": "COALESCE(array_position(ARRAY[val1, val2, ..., valN], val), 0)",
                "description": "Returns the index (1-based) of 'val' in the array. Returns 0 if not found, emulating MySQL FIELD().",
                "examples": [
                    "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'c'), 0) AS result;",
                    "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'x'), 0) AS result;",
                    "SELECT COALESCE(array_position(ARRAY['b', 'b', 'b'], 'b'), 0) AS result;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_4_4",
        "database_name": "duckdb_4_4",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775807 AND TRIM(a) = b; -- TRIM",
        "target_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775807 AND TRIM(CAST(a AS VARCHAR)) = b;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TRIM"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
                "description": "The TRIM function removes unwanted characters from the beginning and/or end of a string. If no character is specified, it removes spaces by default. You can specify 'BOTH', 'LEADING', or 'TRAILING' to trim characters from both ends, the start, or the end, respectively.",
                "examples": [
                    "SELECT TRIM('x' FROM 'xxabcx');",
                    "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
                    "SELECT TRIM(LEADING '0' FROM '000123');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
                "description": "DuckDB's TRIM function is identical to MySQL's, removing unwanted characters from the beginning or end of a string, or from both ends if specified.",
                "examples": [
                    "SELECT TRIM('x' FROM 'xxabcx');",
                    "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
                    "SELECT TRIM(LEADING '0' FROM '000123');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(id, int, PRI)\n(a, bigint unsigned, )\n(b, varchar(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(id, INTEGER, )\n(a, BIGINT, )\n(b, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_4_5",
        "database_name": "duckdb_4_5",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775806 AND TRIM(a) = b; -- TRIM",
        "target_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775806 AND TRIM(CAST(a AS VARCHAR)) = b;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TRIM"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
                "description": "The TRIM function removes unwanted characters from the beginning and/or end of a string. If no character is specified, it removes spaces by default. You can specify 'BOTH', 'LEADING', or 'TRAILING' to trim characters from both ends, the start, or the end, respectively.",
                "examples": [
                    "SELECT TRIM('x' FROM 'xxabcx');",
                    "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
                    "SELECT TRIM(LEADING '0' FROM '000123');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
                "description": "DuckDB's TRIM function is identical to MySQL's, removing unwanted characters from the beginning or end of a string, or from both ends if specified.",
                "examples": [
                    "SELECT TRIM('x' FROM 'xxabcx');",
                    "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
                    "SELECT TRIM(LEADING '0' FROM '000123');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(id, int, PRI)\n(a, bigint unsigned, )\n(b, varchar(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(id, INTEGER, )\n(a, BIGINT, )\n(b, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_4_6",
        "database_name": "duckdb_4_6",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775805 AND TRIM(a) = b; -- TRIM",
        "target_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775805 AND TRIM(CAST(a AS VARCHAR)) = b;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TRIM"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
                "description": "The TRIM function removes unwanted characters from the beginning and/or end of a string. If no character is specified, it removes spaces by default. You can specify 'BOTH', 'LEADING', or 'TRAILING' to trim characters from both ends, the start, or the end, respectively.",
                "examples": [
                    "SELECT TRIM('x' FROM 'xxabcx');",
                    "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
                    "SELECT TRIM(LEADING '0' FROM '000123');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
                "description": "DuckDB's TRIM function is identical to MySQL's, removing unwanted characters from the beginning or end of a string, or from both ends if specified.",
                "examples": [
                    "SELECT TRIM('x' FROM 'xxabcx');",
                    "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
                    "SELECT TRIM(LEADING '0' FROM '000123');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(id, int, PRI)\n(a, bigint unsigned, )\n(b, varchar(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(id, INTEGER, )\n(a, BIGINT, )\n(b, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_4_7",
        "database_name": "duckdb_4_7",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 0 AND TRIM(a) = b; -- TRIM",
        "target_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 0 AND TRIM(CAST(a AS VARCHAR)) = b;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TRIM"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
                "description": "The TRIM function removes unwanted characters from the beginning and/or end of a string. If no character is specified, it removes spaces by default. You can specify 'BOTH', 'LEADING', or 'TRAILING' to trim characters from both ends, the start, or the end, respectively.",
                "examples": [
                    "SELECT TRIM('x' FROM 'xxabcx');",
                    "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
                    "SELECT TRIM(LEADING '0' FROM '000123');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
                "description": "DuckDB's TRIM function is identical to MySQL's, removing unwanted characters from the beginning or end of a string, or from both ends if specified.",
                "examples": [
                    "SELECT TRIM('x' FROM 'xxabcx');",
                    "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
                    "SELECT TRIM(LEADING '0' FROM '000123');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(id, int, PRI)\n(a, bigint unsigned, )\n(b, varchar(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(id, INTEGER, )\n(a, BIGINT, )\n(b, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_4_11",
        "database_name": "duckdb_4_11",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT * FROM t1 WHERE coalesce(a) BETWEEN 0 and 0.9; -- COALESCE",
        "target_query": "SELECT * FROM t1 WHERE COALESCE(CAST(a AS DOUBLE)) BETWEEN 0 AND 0.9;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "COALESCE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
                "description": "Returns the first non-NULL value, or merges table partitions.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
                    "ALTER TABLE t1 COALESCE PARTITION 2;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...)",
                "description": "DuckDB supports COALESCE for NULL handling.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, bigint, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, BIGINT, )\n"
        ]
    },
    {
        "sql_id": "duckdb_4_12",
        "database_name": "duckdb_4_12",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT * FROM t1 WHERE coalesce(a)=0.9; -- COALESCE",
        "target_query": "SELECT * FROM t1 WHERE COALESCE(CAST(a AS DOUBLE)) = 0.9;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "COALESCE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
                "description": "Returns the first non-NULL value, or merges table partitions.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
                    "ALTER TABLE t1 COALESCE PARTITION 2;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...)",
                "description": "DuckDB supports COALESCE for NULL handling.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, bigint, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, BIGINT, )\n"
        ]
    },
    {
        "sql_id": "duckdb_4_13",
        "database_name": "duckdb_4_13",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT * FROM t1 WHERE coalesce(a) in (0.8,0.9); -- COALESCE",
        "target_query": "SELECT * FROM t1 WHERE COALESCE(CAST(a AS DOUBLE)) IN (0.8, 0.9);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "COALESCE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
                "description": "Returns the first non-NULL value, or merges table partitions.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
                    "ALTER TABLE t1 COALESCE PARTITION 2;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...)",
                "description": "DuckDB supports COALESCE for NULL handling.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, bigint, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, BIGINT, )\n"
        ]
    },
    {
        "sql_id": "duckdb_6_3",
        "database_name": "duckdb_6_3",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT HEX(c1) FROM t1; -- HEX",
        "target_query": "SELECT HEX(c1) FROM t1; -- HEX",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts numeric or string values into their hexadecimal string representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, char(4), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_6_5",
        "database_name": "duckdb_6_5",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "CREATE TABLE t1 SELECT repeat('a',4000) a; -- REPEAT",
        "target_query": "CREATE TABLE t1 AS SELECT repeat('a', 4000) AS a; -- REPEAT",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, text, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_6_12",
        "database_name": "duckdb_6_12",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "CREATE TABLE head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2; -- CONCAT",
        "target_query": "CREATE TABLE head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2; -- CONCAT",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
                "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT 'Year: ' || 2025;",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `head`\nColumns:\n(head, varchar(4), )\n",
            "Table: `t1`\nColumns:\n(b, varchar(2), )\n"
        ],
        "target_related_schemas": [
            "Table: `head`\nColumns:\n(head, VARCHAR, )\n",
            "Table: `t1`\nColumns:\n(b, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_6_13",
        "database_name": "duckdb_6_13",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "CREATE TABLE tail AS SELECT concat(b1.b, b2.b) AS tail FROM t1 b1, t1 b2; -- CONCAT",
        "target_query": "CREATE TABLE tail AS SELECT concat(b1.b, b2.b) AS tail FROM t1 b1, t1 b2; -- CONCAT",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
                "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT 'Year: ' || 2025;",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `head`\nColumns:\n(head, varchar(4), )\n",
            "Table: `t1`\nColumns:\n(b, varchar(2), )\n",
            "Table: `tail`\nColumns:\n(tail, varchar(4), )\n"
        ],
        "target_related_schemas": [
            "Table: `head`\nColumns:\n(head, VARCHAR, )\n",
            "Table: `t1`\nColumns:\n(b, VARCHAR, )\n",
            "Table: `tail`\nColumns:\n(tail, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_6_18",
        "database_name": "duckdb_6_18",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "UPDATE IGNORE t1 SET a=unhex(code); -- UNHEX",
        "target_query": "UPDATE t1 SET a=FROM_HEX(code); -- UNHEX",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNHEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNHEX(str)",
                "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
                "examples": [
                    "SELECT HEX(UNHEX('4D7953514C'));",
                    "SELECT UNHEX('48656C6C6F');",
                    "SELECT UNHEX(NULL);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "FROM_HEX(str)",
                "description": "Converts a hexadecimal string into a BLOB value. Returns NULL for invalid hex or NULL input.",
                "examples": [
                    "SELECT TO_HEX(FROM_HEX('4D7953514C'));",
                    "SELECT FROM_HEX('48656C6C6F');",
                    "SELECT FROM_HEX(NULL);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(code, varchar(6), )\n(a, varchar(1), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(code, VARCHAR, )\n(a, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_6_19",
        "database_name": "duckdb_6_19",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT COUNT(*) FROM t1 WHERE a<>'' AND OCTET_LENGTH(a)=2; -- OCTET_LENGTH",
        "target_query": "SELECT COUNT(*) FROM t1 WHERE a<>'' AND LENGTH(a)=2; -- OCTET_LENGTH",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "OCTET_LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "OCTET_LENGTH()",
                "description": "Returns the number of bytes in a string.",
                "examples": [
                    "SELECT OCTET_LENGTH('Hello World');",
                    "SELECT OCTET_LENGTH('Test String') = 11;",
                    "SELECT CASE WHEN OCTET_LENGTH('Example') > 5 THEN 'Long' ELSE 'Short' END;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LENGTH()",
                "description": "Returns the number of bytes in a string.",
                "examples": [
                    "SELECT LENGTH('Hello World');",
                    "SELECT LENGTH('Test String') = 11;",
                    "SELECT CASE WHEN LENGTH('Example') > 5 THEN 'Long' ELSE 'Short' END;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(code, varchar(6), )\n(a, varchar(1), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(code, VARCHAR, )\n(a, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_6_20",
        "database_name": "duckdb_6_20",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT * FROM t1 WHERE CHAR_LENGTH(a)=2; -- CHAR_LENGTH",
        "target_query": "SELECT * FROM t1 WHERE LENGTH(a)=2; -- CHAR_LENGTH",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CHAR_LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CHAR_LENGTH(expr)",
                "description": "Returns the number of characters in the string, not bytes.",
                "examples": [
                    "SELECT CHAR_LENGTH('abc');",
                    "SELECT CHAR_LENGTH('\u4f60\u597d');",
                    "SELECT CHAR_LENGTH('a\u4f60b\u597dc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "length(expr)",
                "description": "Returns the number of characters in a string.",
                "examples": [
                    "SELECT length('abc');",
                    "SELECT length('\u4f60\u597d');",
                    "SELECT length('a\u4f60b\u597dc');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(code, varchar(6), )\n(a, varchar(1), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(code, VARCHAR, )\n(a, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_6_21",
        "database_name": "duckdb_6_21",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT COUNT(*) FROM t1 WHERE a<>'' AND OCTET_LENGTH(a)=3; -- OCTET_LENGTH",
        "target_query": "SELECT COUNT(*) FROM t1 WHERE a<>'' AND LENGTH(a)=3; -- OCTET_LENGTH",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "OCTET_LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "OCTET_LENGTH()",
                "description": "Returns the number of bytes in a string.",
                "examples": [
                    "SELECT OCTET_LENGTH('Hello World');",
                    "SELECT OCTET_LENGTH('Test String') = 11;",
                    "SELECT CASE WHEN OCTET_LENGTH('Example') > 5 THEN 'Long' ELSE 'Short' END;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LENGTH()",
                "description": "Returns the number of bytes in a string.",
                "examples": [
                    "SELECT LENGTH('Hello World');",
                    "SELECT LENGTH('Test String') = 11;",
                    "SELECT CASE WHEN LENGTH('Example') > 5 THEN 'Long' ELSE 'Short' END;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(code, varchar(6), )\n(a, varchar(1), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(code, VARCHAR, )\n(a, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_7_4",
        "database_name": "duckdb_7_4",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT c1, LENGTH(c1) FROM h; -- LENGTH",
        "target_query": "SELECT c1, length(c1) FROM h; -- LENGTH",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "length(str)",
                "description": "Returns the number of bytes in the input string.",
                "examples": [
                    "SELECT length('abc');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `h`\nColumns:\n(c1, char(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `h`\nColumns:\n(c1, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_7_5",
        "database_name": "duckdb_7_5",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT c1, LPAD(c1, 20, ' ') FROM h; -- LPAD",
        "target_query": "SELECT c1, LPAD(c1, 20, ' ') FROM h; -- LPAD",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `h`\nColumns:\n(c1, char(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `h`\nColumns:\n(c1, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_7_6",
        "database_name": "duckdb_7_6",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT c1, RPAD(c1, 20, '52') FROM h; -- RPAD",
        "target_query": "SELECT c1, RPAD(c1, 20, '52') FROM h; -- RPAD",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "RPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "DuckDB supports RPAD for string padding.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123::TEXT, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `h`\nColumns:\n(c1, char(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `h`\nColumns:\n(c1, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_7_9",
        "database_name": "duckdb_7_9",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT INSTR(c1, 'h') FROM h; -- INSTR",
        "target_query": "SELECT INSTR(c1, 'h') FROM h; -- INSTR",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "INSTR(str, substr)",
                "description": "Returns the position of the first occurrence of substr in str, starting from 1. Returns 0 if not found. If substr is an empty string, returns 1. NULL if either argument is NULL.",
                "examples": [
                    "SELECT INSTR('foobar', 'bar');  -- Returns 4",
                    "SELECT INSTR('foobar', 'baz');  -- Returns 0",
                    "SELECT INSTR('foobar', '');     -- Returns 1",
                    "SELECT INSTR(NULL, 'bar');      -- Returns NULL"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "instr(str, substr)",
                "description": "Returns the position of substr in str (1-based). Returns 0 if not found.",
                "examples": [
                    "SELECT instr('foobar', 'bar');    -- Returns 4",
                    "SELECT instr('hello', 'x');       -- Returns 0"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `h`\nColumns:\n(c1, char(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `h`\nColumns:\n(c1, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_7_10",
        "database_name": "duckdb_7_10",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT INSTR(c1, '') FROM h; -- INSTR",
        "target_query": "SELECT INSTR(c1, '') FROM h; -- INSTR",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "INSTR(str, substr)",
                "description": "Returns the position of the first occurrence of substr in str, starting from 1. Returns 0 if not found. If substr is an empty string, returns 1. NULL if either argument is NULL.",
                "examples": [
                    "SELECT INSTR('foobar', 'bar');  -- Returns 4",
                    "SELECT INSTR('foobar', 'baz');  -- Returns 0",
                    "SELECT INSTR('foobar', '');     -- Returns 1",
                    "SELECT INSTR(NULL, 'bar');      -- Returns NULL"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "instr(str, substr)",
                "description": "Returns the position of substr in str (1-based). Returns 0 if not found.",
                "examples": [
                    "SELECT instr('foobar', 'bar');    -- Returns 4",
                    "SELECT instr('hello', 'x');       -- Returns 0"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `h`\nColumns:\n(c1, char(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `h`\nColumns:\n(c1, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_7_11",
        "database_name": "duckdb_7_11",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT INSTR(c1, '52') FROM h; -- INSTR",
        "target_query": "SELECT INSTR(c1, '52') FROM h; -- INSTR",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "INSTR(str, substr)",
                "description": "Returns the position of the first occurrence of substr in str, starting from 1. Returns 0 if not found. If substr is an empty string, returns 1. NULL if either argument is NULL.",
                "examples": [
                    "SELECT INSTR('foobar', 'bar');  -- Returns 4",
                    "SELECT INSTR('foobar', 'baz');  -- Returns 0",
                    "SELECT INSTR('foobar', '');     -- Returns 1",
                    "SELECT INSTR(NULL, 'bar');      -- Returns NULL"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "instr(str, substr)",
                "description": "Returns the position of substr in str (1-based). Returns 0 if not found.",
                "examples": [
                    "SELECT instr('foobar', 'bar');    -- Returns 4",
                    "SELECT instr('hello', 'x');       -- Returns 0"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `h`\nColumns:\n(c1, char(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `h`\nColumns:\n(c1, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_7_12",
        "database_name": "duckdb_7_12",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT INSTR(c1, '54') FROM h; -- INSTR",
        "target_query": "SELECT INSTR(c1, '54') FROM h; -- INSTR",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "INSTR(str, substr)",
                "description": "Returns the position of the first occurrence of substr in str, starting from 1. Returns 0 if not found. If substr is an empty string, returns 1. NULL if either argument is NULL.",
                "examples": [
                    "SELECT INSTR('foobar', 'bar');  -- Returns 4",
                    "SELECT INSTR('foobar', 'baz');  -- Returns 0",
                    "SELECT INSTR('foobar', '');     -- Returns 1",
                    "SELECT INSTR(NULL, 'bar');      -- Returns NULL"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "instr(str, substr)",
                "description": "Returns the position of substr in str (1-based). Returns 0 if not found.",
                "examples": [
                    "SELECT instr('foobar', 'bar');    -- Returns 4",
                    "SELECT instr('hello', 'x');       -- Returns 0"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `h`\nColumns:\n(c1, char(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `h`\nColumns:\n(c1, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_7_13",
        "database_name": "duckdb_7_13",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT INSTR(c1, '31') FROM h; -- INSTR",
        "target_query": "SELECT INSTR(c1, '31') FROM h; -- INSTR",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "INSTR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "INSTR(str, substr)",
                "description": "Returns the position of the first occurrence of substr in str, starting from 1. Returns 0 if not found. If substr is an empty string, returns 1. NULL if either argument is NULL.",
                "examples": [
                    "SELECT INSTR('foobar', 'bar');  -- Returns 4",
                    "SELECT INSTR('foobar', 'baz');  -- Returns 0",
                    "SELECT INSTR('foobar', '');     -- Returns 1",
                    "SELECT INSTR(NULL, 'bar');      -- Returns NULL"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "instr(str, substr)",
                "description": "Returns the position of substr in str (1-based). Returns 0 if not found.",
                "examples": [
                    "SELECT instr('foobar', 'bar');    -- Returns 4",
                    "SELECT instr('hello', 'x');       -- Returns 0"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `h`\nColumns:\n(c1, char(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `h`\nColumns:\n(c1, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_7_23",
        "database_name": "duckdb_7_23",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT c1, TRIM(c1) FROM h; -- TRIM",
        "target_query": "SELECT c1, TRIM(c1) FROM h; -- TRIM",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TRIM"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
                "description": "The TRIM function removes unwanted characters from the beginning and/or end of a string. If no character is specified, it removes spaces by default. You can specify 'BOTH', 'LEADING', or 'TRAILING' to trim characters from both ends, the start, or the end, respectively.",
                "examples": [
                    "SELECT TRIM('x' FROM 'xxabcx');",
                    "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
                    "SELECT TRIM(LEADING '0' FROM '000123');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
                "description": "DuckDB's TRIM function is identical to MySQL's, removing unwanted characters from the beginning or end of a string, or from both ends if specified.",
                "examples": [
                    "SELECT TRIM('x' FROM 'xxabcx');",
                    "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
                    "SELECT TRIM(LEADING '0' FROM '000123');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `h`\nColumns:\n(c1, char(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `h`\nColumns:\n(c1, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_71_0",
        "database_name": "duckdb_71_0",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select from_unixtime(123456789); -- FROM_UNIXTIME",
        "target_query": "SELECT TO_TIMESTAMP(123456789);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "FROM_UNIXTIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
                "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
                "examples": [
                    "SELECT FROM_UNIXTIME(1672531200);",
                    "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
                    "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_TIMESTAMP(unix_timestamp)",
                "description": "Converts a Unix timestamp (seconds since epoch) to a TIMESTAMP value.",
                "examples": [
                    "SELECT TO_TIMESTAMP(1672531200);",
                    "SELECT TO_TIMESTAMP(1672531200.789);",
                    "SELECT id, TO_TIMESTAMP(event_time) AS event_ts FROM events;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_71_1",
        "database_name": "duckdb_71_1",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select from_unixtime(234567890); -- FROM_UNIXTIME",
        "target_query": "SELECT TO_TIMESTAMP(234567890);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "FROM_UNIXTIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
                "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
                "examples": [
                    "SELECT FROM_UNIXTIME(1672531200);",
                    "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
                    "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_TIMESTAMP(unix_timestamp)",
                "description": "Converts a Unix timestamp (seconds since epoch) to a TIMESTAMP value.",
                "examples": [
                    "SELECT TO_TIMESTAMP(1672531200);",
                    "SELECT TO_TIMESTAMP(1672531200.789);",
                    "SELECT id, TO_TIMESTAMP(event_time) AS event_ts FROM events;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_71_2",
        "database_name": "duckdb_71_2",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select from_unixtime(1); -- FROM_UNIXTIME",
        "target_query": "SELECT TO_TIMESTAMP(1);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "FROM_UNIXTIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
                "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
                "examples": [
                    "SELECT FROM_UNIXTIME(1672531200);",
                    "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
                    "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_TIMESTAMP(unix_timestamp)",
                "description": "Converts a Unix timestamp (seconds since epoch) to a TIMESTAMP value.",
                "examples": [
                    "SELECT TO_TIMESTAMP(1672531200);",
                    "SELECT TO_TIMESTAMP(1672531200.789);",
                    "SELECT id, TO_TIMESTAMP(event_time) AS event_ts FROM events;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_71_3",
        "database_name": "duckdb_71_3",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select unix_timestamp(from_unixtime(123456789)); -- UNIX_TIMESTAMP, FROM_UNIXTIME",
        "target_query": "SELECT EXTRACT(EPOCH FROM TO_TIMESTAMP(123456789));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNIX_TIMESTAMP",
            "FROM_UNIXTIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            },
            {
                "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
                "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
                "examples": [
                    "SELECT FROM_UNIXTIME(1672531200);",
                    "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
                    "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            },
            {
                "expression": "TO_TIMESTAMP(unix_timestamp)",
                "description": "Converts a Unix timestamp (seconds since epoch) to a TIMESTAMP value.",
                "examples": [
                    "SELECT TO_TIMESTAMP(1672531200);",
                    "SELECT TO_TIMESTAMP(1672531200.789);",
                    "SELECT id, TO_TIMESTAMP(event_time) AS event_ts FROM events;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_71_4",
        "database_name": "duckdb_71_4",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select unix_timestamp(from_unixtime(234567890)); -- UNIX_TIMESTAMP, FROM_UNIXTIME",
        "target_query": "SELECT EXTRACT(EPOCH FROM TO_TIMESTAMP(234567890));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNIX_TIMESTAMP",
            "FROM_UNIXTIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            },
            {
                "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
                "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
                "examples": [
                    "SELECT FROM_UNIXTIME(1672531200);",
                    "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
                    "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            },
            {
                "expression": "TO_TIMESTAMP(unix_timestamp)",
                "description": "Converts a Unix timestamp (seconds since epoch) to a TIMESTAMP value.",
                "examples": [
                    "SELECT TO_TIMESTAMP(1672531200);",
                    "SELECT TO_TIMESTAMP(1672531200.789);",
                    "SELECT id, TO_TIMESTAMP(event_time) AS event_ts FROM events;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_71_5",
        "database_name": "duckdb_71_5",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select unix_timestamp('2039-01-20 01:00:00'); -- UNIX_TIMESTAMP",
        "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2039-01-20 01:00:00');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNIX_TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_71_6",
        "database_name": "duckdb_71_6",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select unix_timestamp('2038-02-10 01:00:00'); -- UNIX_TIMESTAMP",
        "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-02-10 01:00:00');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNIX_TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_71_7",
        "database_name": "duckdb_71_7",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select unix_timestamp('1970-01-01 01:00:00'),unix_timestamp('1970-01-01 01:00:01'),unix_timestamp('2038-01-19 04:14:07'),unix_timestamp('2038-01-19 04:14:08'); -- UNIX_TIMESTAMP",
        "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '1970-01-01 01:00:00'), EXTRACT(EPOCH FROM TIMESTAMP '1970-01-01 01:00:01'), EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07'), EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:08');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNIX_TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_71_11",
        "database_name": "duckdb_71_11",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT a, FROM_UNIXTIME(a) FROM t1; -- FROM_UNIXTIME",
        "target_query": "SELECT a, TO_TIMESTAMP(a) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "FROM_UNIXTIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
                "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
                "examples": [
                    "SELECT FROM_UNIXTIME(1672531200);",
                    "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
                    "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TO_TIMESTAMP(unix_timestamp)",
                "description": "Converts a Unix timestamp (seconds since epoch) to a TIMESTAMP value.",
                "examples": [
                    "SELECT TO_TIMESTAMP(1672531200);",
                    "SELECT TO_TIMESTAMP(1672531200.789);",
                    "SELECT id, TO_TIMESTAMP(event_time) AS event_ts FROM events;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, bigint, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, BIGINT, )\n"
        ]
    },
    {
        "sql_id": "duckdb_71_13",
        "database_name": "duckdb_71_13",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT UNIX_TIMESTAMP(\"3001-01-19 08:59:59\"); -- UNIX_TIMESTAMP",
        "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '3001-01-19 08:59:59');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNIX_TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_72_4",
        "database_name": "duckdb_72_4",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "EXPLAIN SELECT * FROM t WHERE CONCAT(x,x) = 'XX'; -- CONCAT",
        "target_query": "EXPLAIN SELECT * FROM t WHERE CONCAT(x, x) = 'XX';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
                "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT 'Year: ' || 2025;",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t`\nColumns:\n(x, varchar(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t`\nColumns:\n(x, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_74_2",
        "database_name": "duckdb_74_2",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "insert into t1(f1) select if(max(f1) is null, '2000',max(f1)) from t1; -- IF, MAX",
        "target_query": "INSERT INTO t1(f1) SELECT CASE WHEN MAX(f1) IS NULL THEN '2000' ELSE MAX(f1) END FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IF",
            "MAX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            },
            {
                "expression": "MAX(expr)",
                "description": "Returns the maximum value of the expression in an aggregation context.",
                "examples": [
                    "SELECT MAX(10), MAX(5), MAX(20);",
                    "SELECT MAX('apple'), MAX('banana'), MAX('pear');",
                    "SELECT MAX(ABS(-5)), MAX(ABS(3));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "DuckDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It allows you to return different values based on a given condition.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            },
            {
                "expression": "MAX(expr)",
                "description": "Returns the maximum value among all input values.",
                "examples": [
                    "SELECT MAX(1), MAX(5), MAX(3);",
                    "SELECT MAX('orange'), MAX('apple'), MAX('banana');",
                    "SELECT MAX(length('abc')), MAX(length('defg'));"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(f1, varchar(5), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(f1, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_74_6",
        "database_name": "duckdb_74_6",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT (SELECT SUM(LENGTH(c)) FROM t1 WHERE c='13_characters') FROM t1; -- LENGTH",
        "target_query": "SELECT (SELECT SUM(length(c)) FROM t1 WHERE c='13_characters') FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "length(str)",
                "description": "Returns the number of bytes in the input string.",
                "examples": [
                    "SELECT length('abc');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(c, varchar(30), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(c, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_74_9",
        "database_name": "duckdb_74_9",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "INSERT INTO t2 (d)SELECT (SELECT SUM(LENGTH(c)) FROM t1 WHERE c='13_characters') FROM t1; -- LENGTH",
        "target_query": "INSERT INTO t2 (d)SELECT (SELECT SUM(length(c)) FROM t1 WHERE c='13_characters') FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "length(str)",
                "description": "Returns the number of bytes in the input string.",
                "examples": [
                    "SELECT length('abc');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(c, varchar(30), )\n",
            "Table: `t2`\nColumns:\n(d, varchar(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(c, VARCHAR, )\n",
            "Table: `t2`\nColumns:\n(d, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_74_10",
        "database_name": "duckdb_74_10",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "INSERT INTO t2 (d)SELECT (SELECT SUM(LENGTH(c)) FROM t1 WHERE c='7_chars') FROM t1; -- LENGTH",
        "target_query": "INSERT INTO t2 (d)SELECT (SELECT SUM(length(c)) FROM t1 WHERE c='7_chars') FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "length(str)",
                "description": "Returns the number of bytes in the input string.",
                "examples": [
                    "SELECT length('abc');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(c, varchar(30), )\n",
            "Table: `t2`\nColumns:\n(d, varchar(10), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(c, VARCHAR, )\n",
            "Table: `t2`\nColumns:\n(d, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_74_16",
        "database_name": "duckdb_74_16",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT *, HEX(a) FROM t1; -- HEX",
        "target_query": "SELECT *, HEX(a) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts numeric or string values into their hexadecimal string representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(id, int, PRI)\n(a, varchar(100), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(id, INTEGER, )\n(a, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_74_17",
        "database_name": "duckdb_74_17",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT *, HEX(a) FROM t1 WHERE a = 'abc-def'; -- HEX",
        "target_query": "SELECT *, HEX(a) FROM t1 WHERE a = 'abc-def';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts numeric or string values into their hexadecimal string representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(id, int, PRI)\n(a, varchar(100), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(id, INTEGER, )\n(a, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_75_2",
        "database_name": "duckdb_75_2",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "INSERT INTO t1 VALUES('valid-string',1),(UNHEX('11'),2); -- UNHEX",
        "target_query": "INSERT INTO t1 VALUES('valid-string', 1), (FROM_HEX('11'), 2);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNHEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNHEX(str)",
                "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
                "examples": [
                    "SELECT HEX(UNHEX('4D7953514C'));",
                    "SELECT UNHEX('48656C6C6F');",
                    "SELECT UNHEX(NULL);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "FROM_HEX(str)",
                "description": "Converts a hexadecimal string into a BLOB value. Returns NULL for invalid hex or NULL input.",
                "examples": [
                    "SELECT TO_HEX(FROM_HEX('4D7953514C'));",
                    "SELECT FROM_HEX('48656C6C6F');",
                    "SELECT FROM_HEX(NULL);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(tx, text, )\n(pk, int, PRI)\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(tx, VARCHAR, )\n(pk, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_75_3",
        "database_name": "duckdb_75_3",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT pk,OCTET_LENGTH(tx),LENGTH(tx) FROM t1; -- OCTET_LENGTH, LENGTH",
        "target_query": "SELECT pk, LENGTH(tx), LENGTH(tx) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "OCTET_LENGTH",
            "LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "OCTET_LENGTH()",
                "description": "Returns the number of bytes in a string.",
                "examples": [
                    "SELECT OCTET_LENGTH('Hello World');",
                    "SELECT OCTET_LENGTH('Test String') = 11;",
                    "SELECT CASE WHEN OCTET_LENGTH('Example') > 5 THEN 'Long' ELSE 'Short' END;"
                ]
            },
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LENGTH()",
                "description": "Returns the number of bytes in a string.",
                "examples": [
                    "SELECT LENGTH('Hello World');",
                    "SELECT LENGTH('Test String') = 11;",
                    "SELECT CASE WHEN LENGTH('Example') > 5 THEN 'Long' ELSE 'Short' END;"
                ]
            },
            {
                "expression": "length(str)",
                "description": "Returns the number of bytes in the input string.",
                "examples": [
                    "SELECT length('abc');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(tx, text, )\n(pk, int, PRI)\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(tx, VARCHAR, )\n(pk, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_76_2",
        "database_name": "duckdb_76_2",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "insert ignore t1 values (1, repeat('a',110), repeat('b', 210)); -- REPEAT",
        "target_query": "insert into t1 values (1, repeat('a',110), repeat('b', 210));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(i, int, )\n(a, char(200), UNI)\n(b, text, UNI)\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(i, INTEGER, )\n(a, VARCHAR, )\n(b, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_76_3",
        "database_name": "duckdb_76_3",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select i, length(a), length(b), char_length(a), char_length(b) from t1; -- LENGTH, CHAR_LENGTH",
        "target_query": "select i, length(a), length(b), length(a), length(b) from t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH",
            "CHAR_LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            },
            {
                "expression": "CHAR_LENGTH(expr)",
                "description": "Returns the number of characters in the string, not bytes.",
                "examples": [
                    "SELECT CHAR_LENGTH('abc');",
                    "SELECT CHAR_LENGTH('\u4f60\u597d');",
                    "SELECT CHAR_LENGTH('a\u4f60b\u597dc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "length(str)",
                "description": "Returns the number of bytes in the input string.",
                "examples": [
                    "SELECT length('abc');"
                ]
            },
            {
                "expression": "length(expr)",
                "description": "Returns the number of characters in a string.",
                "examples": [
                    "SELECT length('abc');",
                    "SELECT length('\u4f60\u597d');",
                    "SELECT length('a\u4f60b\u597dc');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(i, int, )\n(a, char(200), UNI)\n(b, text, UNI)\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(i, INTEGER, )\n(a, VARCHAR, )\n(b, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_76_6",
        "database_name": "duckdb_76_6",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "insert into t1 values(1, 'a', 'a', NOW()), (1, 'b', 'b', NOW()); -- NOW",
        "target_query": "insert into t1 values(1, 'a', 'a', CURRENT_TIMESTAMP), (1, 'b', 'b', CURRENT_TIMESTAMP);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "NOW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "NOW()",
                "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
                "examples": [
                    "SELECT NOW();",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (NOW());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "DuckDB also uses CURRENT_TIMESTAMP to get the current date and time, similar to PostgreSQL and MonetDB.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, int, )\n(c2, char(12), )\n(c3, varchar(123), )\n(c4, timestamp, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, INTEGER, )\n(c2, VARCHAR, )\n(c3, VARCHAR, )\n(c4, TIMESTAMP, )\n"
        ]
    },
    {
        "sql_id": "duckdb_77_3",
        "database_name": "duckdb_77_3",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select t1.time,t1.date,t1.timestamp,concat(date,\" \",time),t1.quarter+t1.week, t1.year+timestampadd,  timestampdiff from t1; -- CONCAT",
        "target_query": "select t1.time,t1.date,t1.timestamp,CONCAT(date, ' ', time),t1.quarter+t1.week, t1.year+timestampadd, timestampdiff from t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
                "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT 'Year: ' || 2025;",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(time, time, )\n(date, date, )\n(timestamp, timestamp, )\n(quarter, int, )\n(week, int, )\n(year, int, )\n(timestampadd, int, )\n(timestampdiff, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(time, TIME, )\n(date, DATE, )\n(timestamp, TIMESTAMP, )\n(quarter, INTEGER, )\n(week, INTEGER, )\n(year, INTEGER, )\n(timestampadd, INTEGER, )\n(timestampdiff, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_78_2",
        "database_name": "duckdb_78_2",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select concat('|',a,'|'), concat('|',b,'|') from t1; -- CONCAT",
        "target_query": "select CONCAT('|',a,'|'), CONCAT('|',b,'|') from t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
                "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT 'Year: ' || 2025;",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, text, )\n(b, text, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, VARCHAR, )\n(b, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_78_5",
        "database_name": "duckdb_78_5",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT HEX(val) FROM t1; -- HEX",
        "target_query": "SELECT HEX(val) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts numeric or string values into their hexadecimal string representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(val, text, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(val, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_78_8",
        "database_name": "duckdb_78_8",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT HEX(a) FROM t1; -- HEX",
        "target_query": "SELECT HEX(a) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts numeric or string values into their hexadecimal string representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, varchar(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_79_3",
        "database_name": "duckdb_79_3",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT a, date_format(a,'%a') as abday, dayname(a) as day FROM t1 ORDER BY a; -- DATE_FORMAT, DAYNAME",
        "target_query": "SELECT a, STRFTIME(a,'%a') as abday, dayname(a) as day FROM t1 ORDER BY a;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "DATE_FORMAT",
            "DAYNAME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_FORMAT(date_expr, format_str)",
                "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
                "examples": [
                    "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
                    "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
                ]
            },
            {
                "expression": "DAYNAME(date)",
                "description": "Returns the full name of the day for a given date.",
                "examples": [
                    "SELECT DAYNAME('2023-11-25');",
                    "SELECT DAYNAME('2022-01-01');",
                    "SELECT DAYNAME('1999-03-14');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "STRFTIME(date_expr, format_str)",
                "description": "Formats a date/time value using SQLite-compatible strftime format specifiers.",
                "examples": [
                    "SELECT STRFTIME('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT STRFTIME(CURRENT_TIMESTAMP, '%Y-%m-%d %H:%M:%S');",
                    "SELECT STRFTIME('2023-01-15 12:00:00', '%d-%m-%Y');"
                ]
            },
            {
                "expression": "dayname(date)",
                "description": "Returns the full name of the day for a given date.",
                "examples": [
                    "SELECT dayname(DATE '2023-11-25');",
                    "SELECT dayname(DATE '2022-01-01');",
                    "SELECT dayname(DATE '1999-03-14');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, date, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, DATE, )\n"
        ]
    },
    {
        "sql_id": "duckdb_79_7",
        "database_name": "duckdb_79_7",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT a, date_format(a,'%b') as abmon, monthname(a) as mon FROM t1 ORDER BY a; -- DATE_FORMAT, MONTHNAME",
        "target_query": "SELECT a, STRFTIME(a,'%b') as abmon, monthname(a) as mon FROM t1 ORDER BY a;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "DATE_FORMAT",
            "MONTHNAME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_FORMAT(date_expr, format_str)",
                "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
                "examples": [
                    "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
                    "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
                ]
            },
            {
                "expression": "MONTHNAME(date)",
                "description": "Returns the full English name of the month for a given date.",
                "examples": [
                    "SELECT MONTHNAME(DATE '2023-05-01') AS mon1;",
                    "SELECT MONTHNAME(STR_TO_DATE('2024-12-31', '%Y-%m-%d')) AS mon2;",
                    "SELECT MONTHNAME(NOW()) AS current_month;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "STRFTIME(date_expr, format_str)",
                "description": "Formats a date/time value using SQLite-compatible strftime format specifiers.",
                "examples": [
                    "SELECT STRFTIME('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT STRFTIME(CURRENT_TIMESTAMP, '%Y-%m-%d %H:%M:%S');",
                    "SELECT STRFTIME('2023-01-15 12:00:00', '%d-%m-%Y');"
                ]
            },
            {
                "expression": "monthname(date)",
                "description": "Returns the full English name of the month for a given date.",
                "examples": [
                    "SELECT monthname(DATE '2023-05-01');",
                    "SELECT monthname(DATE '2024-12-31');",
                    "SELECT monthname(CURRENT_DATE);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, date, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, DATE, )\n"
        ]
    },
    {
        "sql_id": "duckdb_79_9",
        "database_name": "duckdb_79_9",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT DATE_FORMAT('2001-01-01', '%w %a %W'); -- DATE_FORMAT",
        "target_query": "SELECT STRFTIME(DATE '2001-01-01', '%w %a %W');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "DATE_FORMAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_FORMAT(date_expr, format_str)",
                "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
                "examples": [
                    "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
                    "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "STRFTIME(date_expr, format_str)",
                "description": "Formats a date/time value using SQLite-compatible strftime format specifiers.",
                "examples": [
                    "SELECT STRFTIME('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT STRFTIME(CURRENT_TIMESTAMP, '%Y-%m-%d %H:%M:%S');",
                    "SELECT STRFTIME('2023-01-15 12:00:00', '%d-%m-%Y');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_79_10",
        "database_name": "duckdb_79_10",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT DATE_FORMAT('2001-01-01', '%c %b %M'); -- DATE_FORMAT",
        "target_query": "SELECT STRFTIME(DATE '2001-01-01', '%c %b %M');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "DATE_FORMAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_FORMAT(date_expr, format_str)",
                "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
                "examples": [
                    "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
                    "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "STRFTIME(date_expr, format_str)",
                "description": "Formats a date/time value using SQLite-compatible strftime format specifiers.",
                "examples": [
                    "SELECT STRFTIME('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT STRFTIME(CURRENT_TIMESTAMP, '%Y-%m-%d %H:%M:%S');",
                    "SELECT STRFTIME('2023-01-15 12:00:00', '%d-%m-%Y');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_79_11",
        "database_name": "duckdb_79_11",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT DATE_FORMAT('2010-03-23 11:00:00','%h %p'); -- DATE_FORMAT",
        "target_query": "SELECT STRFTIME(DATE '2010-03-23 11:00:00','%h %p');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "DATE_FORMAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_FORMAT(date_expr, format_str)",
                "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
                "examples": [
                    "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
                    "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "STRFTIME(date_expr, format_str)",
                "description": "Formats a date/time value using SQLite-compatible strftime format specifiers.",
                "examples": [
                    "SELECT STRFTIME('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT STRFTIME(CURRENT_TIMESTAMP, '%Y-%m-%d %H:%M:%S');",
                    "SELECT STRFTIME('2023-01-15 12:00:00', '%d-%m-%Y');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_8_0",
        "database_name": "duckdb_8_0",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select strcmp('','ae'),strcmp('ae',''),strcmp('aeq','q'),strcmp('q','aeq'); -- STRCMP",
        "target_query": "SELECT CASE WHEN '' = 'ae' THEN 0 WHEN '' < 'ae' THEN -1 ELSE 1 END, CASE WHEN 'ae' = '' THEN 0 WHEN 'ae' < '' THEN -1 ELSE 1 END, CASE WHEN 'aeq' = 'q' THEN 0 WHEN 'aeq' < 'q' THEN -1 ELSE 1 END, CASE WHEN 'q' = 'aeq' THEN 0 WHEN 'q' < 'aeq' THEN -1 ELSE 1 END;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "STRCMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STRCMP(expr1, expr2)",
                "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
                "examples": [
                    "SELECT STRCMP('apple', 'banana');",
                    "SELECT STRCMP('grape', 'grape');",
                    "SELECT STRCMP('orange', 'apple');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
                "description": "DuckDB does not have a STRCMP function, but the same functionality can be achieved using a CASE statement to compare strings lexicographically.",
                "examples": [
                    "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_8_1",
        "database_name": "duckdb_8_1",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select strcmp('ss',''),strcmp('','ss'),strcmp('s','sss'),strcmp('q','ssq'); -- STRCMP",
        "target_query": "SELECT CASE WHEN 'ss' = '' THEN 0 WHEN 'ss' < '' THEN -1 ELSE 1 END, CASE WHEN '' = 'ss' THEN 0 WHEN '' < 'ss' THEN -1 ELSE 1 END, CASE WHEN 's' = 'sss' THEN 0 WHEN 's' < 'sss' THEN -1 ELSE 1 END, CASE WHEN 'q' = 'ssq' THEN 0 WHEN 'q' < 'ssq' THEN -1 ELSE 1 END;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "STRCMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STRCMP(expr1, expr2)",
                "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
                "examples": [
                    "SELECT STRCMP('apple', 'banana');",
                    "SELECT STRCMP('grape', 'grape');",
                    "SELECT STRCMP('orange', 'apple');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
                "description": "DuckDB does not have a STRCMP function, but the same functionality can be achieved using a CASE statement to compare strings lexicographically.",
                "examples": [
                    "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_8_2",
        "database_name": "duckdb_8_2",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select strcmp('','af'),strcmp('a',''),strcmp('','aeq'),strcmp('','aeaeq'); -- STRCMP",
        "target_query": "SELECT CASE WHEN '' = 'af' THEN 0 WHEN '' < 'af' THEN -1 ELSE 1 END, CASE WHEN 'a' = '' THEN 0 WHEN 'a' < '' THEN -1 ELSE 1 END, CASE WHEN '' = 'aeq' THEN 0 WHEN '' < 'aeq' THEN -1 ELSE 1 END, CASE WHEN '' = 'aeaeq' THEN 0 WHEN '' < 'aeaeq' THEN -1 ELSE 1 END;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "STRCMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STRCMP(expr1, expr2)",
                "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
                "examples": [
                    "SELECT STRCMP('apple', 'banana');",
                    "SELECT STRCMP('grape', 'grape');",
                    "SELECT STRCMP('orange', 'apple');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
                "description": "DuckDB does not have a STRCMP function, but the same functionality can be achieved using a CASE statement to compare strings lexicographically.",
                "examples": [
                    "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_8_3",
        "database_name": "duckdb_8_3",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select strcmp('ss','a'),strcmp('','ssa'),strcmp('sa','sssb'),strcmp('s',''); -- STRCMP",
        "target_query": "SELECT CASE WHEN 'ss' = 'a' THEN 0 WHEN 'ss' < 'a' THEN -1 ELSE 1 END, CASE WHEN '' = 'ssa' THEN 0 WHEN '' < 'ssa' THEN -1 ELSE 1 END, CASE WHEN 'sa' = 'sssb' THEN 0 WHEN 'sa' < 'sssb' THEN -1 ELSE 1 END, CASE WHEN 's' = '' THEN 0 WHEN 's' < '' THEN -1 ELSE 1 END;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "STRCMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STRCMP(expr1, expr2)",
                "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
                "examples": [
                    "SELECT STRCMP('apple', 'banana');",
                    "SELECT STRCMP('grape', 'grape');",
                    "SELECT STRCMP('orange', 'apple');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
                "description": "DuckDB does not have a STRCMP function, but the same functionality can be achieved using a CASE statement to compare strings lexicographically.",
                "examples": [
                    "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_8_4",
        "database_name": "duckdb_8_4",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select strcmp('','o'),strcmp('','u'),strcmp('','oeb'); -- STRCMP",
        "target_query": "SELECT CASE WHEN '' = 'o' THEN 0 WHEN '' < 'o' THEN -1 ELSE 1 END, CASE WHEN '' = 'u' THEN 0 WHEN '' < 'u' THEN -1 ELSE 1 END, CASE WHEN '' = 'oeb' THEN 0 WHEN '' < 'oeb' THEN -1 ELSE 1 END;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "STRCMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STRCMP(expr1, expr2)",
                "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
                "examples": [
                    "SELECT STRCMP('apple', 'banana');",
                    "SELECT STRCMP('grape', 'grape');",
                    "SELECT STRCMP('orange', 'apple');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
                "description": "DuckDB does not have a STRCMP function, but the same functionality can be achieved using a CASE statement to compare strings lexicographically.",
                "examples": [
                    "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_8_5",
        "database_name": "duckdb_8_5",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select strcmp('af',''),strcmp('','a'),strcmp('aeq',''),strcmp('aeaeq',''); -- STRCMP",
        "target_query": "SELECT CASE WHEN 'af' = '' THEN 0 WHEN 'af' < '' THEN -1 ELSE 1 END, CASE WHEN '' = 'a' THEN 0 WHEN '' < 'a' THEN -1 ELSE 1 END, CASE WHEN 'aeq' = '' THEN 0 WHEN 'aeq' < '' THEN -1 ELSE 1 END, CASE WHEN 'aeaeq' = '' THEN 0 WHEN 'aeaeq' < '' THEN -1 ELSE 1 END;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "STRCMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STRCMP(expr1, expr2)",
                "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
                "examples": [
                    "SELECT STRCMP('apple', 'banana');",
                    "SELECT STRCMP('grape', 'grape');",
                    "SELECT STRCMP('orange', 'apple');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
                "description": "DuckDB does not have a STRCMP function, but the same functionality can be achieved using a CASE statement to compare strings lexicographically.",
                "examples": [
                    "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_8_6",
        "database_name": "duckdb_8_6",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select strcmp('a','ss'),strcmp('ssa',''),strcmp('sssb','sa'),strcmp('','s'); -- STRCMP",
        "target_query": "SELECT CASE WHEN 'a' = 'ss' THEN 0 WHEN 'a' < 'ss' THEN -1 ELSE 1 END, CASE WHEN 'ssa' = '' THEN 0 WHEN 'ssa' < '' THEN -1 ELSE 1 END, CASE WHEN 'sssb' = 'sa' THEN 0 WHEN 'sssb' < 'sa' THEN -1 ELSE 1 END, CASE WHEN '' = 's' THEN 0 WHEN '' < 's' THEN -1 ELSE 1 END;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "STRCMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STRCMP(expr1, expr2)",
                "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
                "examples": [
                    "SELECT STRCMP('apple', 'banana');",
                    "SELECT STRCMP('grape', 'grape');",
                    "SELECT STRCMP('orange', 'apple');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
                "description": "DuckDB does not have a STRCMP function, but the same functionality can be achieved using a CASE statement to compare strings lexicographically.",
                "examples": [
                    "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_8_7",
        "database_name": "duckdb_8_7",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select strcmp('u','a'),strcmp('u',''); -- STRCMP",
        "target_query": "SELECT CASE WHEN 'u' = 'a' THEN 0 WHEN 'u' < 'a' THEN -1 ELSE 1 END, CASE WHEN 'u' = '' THEN 0 WHEN 'u' < '' THEN -1 ELSE 1 END;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "STRCMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STRCMP(expr1, expr2)",
                "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
                "examples": [
                    "SELECT STRCMP('apple', 'banana');",
                    "SELECT STRCMP('grape', 'grape');",
                    "SELECT STRCMP('orange', 'apple');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
                "description": "DuckDB does not have a STRCMP function, but the same functionality can be achieved using a CASE statement to compare strings lexicographically.",
                "examples": [
                    "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_8_8",
        "database_name": "duckdb_8_8",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select strcmp('s', 'a'), strcmp('a', 'x'); -- STRCMP",
        "target_query": "SELECT CASE WHEN 's' = 'a' THEN 0 WHEN 's' < 'a' THEN -1 ELSE 1 END, CASE WHEN 'a' = 'x' THEN 0 WHEN 'a' < 'x' THEN -1 ELSE 1 END;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "STRCMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STRCMP(expr1, expr2)",
                "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
                "examples": [
                    "SELECT STRCMP('apple', 'banana');",
                    "SELECT STRCMP('grape', 'grape');",
                    "SELECT STRCMP('orange', 'apple');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
                "description": "DuckDB does not have a STRCMP function, but the same functionality can be achieved using a CASE statement to compare strings lexicographically.",
                "examples": [
                    "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_8_13",
        "database_name": "duckdb_8_13",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT FIELD('ue',s1), FIELD('',s1), s1='ue', s1='' FROM t1; -- FIELD",
        "target_query": "SELECT COALESCE(array_position(ARRAY[s1], 'ue'), 0), COALESCE(array_position(ARRAY[s1], ''), 0), s1='ue', s1='' FROM t1; -- FIELD",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "FIELD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "FIELD(val, val1, val2, ..., valN)",
                "description": "Returns the index (1-based) of the first value in the list that is equal to 'val'. Returns 0 if no match is found.",
                "examples": [
                    "SELECT FIELD('c', 'a', 'b', 'c') AS result;",
                    "SELECT FIELD('x', 'a', 'b', 'c') AS result;",
                    "SELECT FIELD('b', 'b', 'b', 'b') AS result;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(array_position(ARRAY[val1, val2, ..., valN], val), 0)",
                "description": "Returns the index (1-based) of 'val' in the array. Returns 0 if not found, emulating MySQL FIELD().",
                "examples": [
                    "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'c'), 0) AS result;",
                    "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'x'), 0) AS result;",
                    "SELECT COALESCE(array_position(ARRAY['b', 'b', 'b'], 'b'), 0) AS result;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(s1, char(5), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(s1, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_8_17",
        "database_name": "duckdb_8_17",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select * from t1 where length(s1)=2 and s1='oe'; -- LENGTH",
        "target_query": "select * from t1 where length(s1)=2 and s1='oe'; -- LENGTH",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "length(str)",
                "description": "Returns the number of bytes in the input string.",
                "examples": [
                    "SELECT length('abc');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(s1, char(5), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(s1, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_80_0",
        "database_name": "duckdb_80_0",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT LPAD(NULL, 5, 'x') AS result; -- LPAD",
        "target_query": "SELECT LPAD(NULL, 5, 'x') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_80_1",
        "database_name": "duckdb_80_1",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT LPAD(NULL, NULL, 'x') AS result; -- LPAD",
        "target_query": "SELECT LPAD(NULL, NULL, 'x') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_80_2",
        "database_name": "duckdb_80_2",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT LPAD(NULL, NULL, NULL) AS result; -- LPAD",
        "target_query": "SELECT LPAD(NULL, NULL, NULL) AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_80_3",
        "database_name": "duckdb_80_3",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT LPAD('a', NULL, 'x') AS result; -- LPAD",
        "target_query": "SELECT LPAD('a', NULL, 'x') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_80_4",
        "database_name": "duckdb_80_4",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT LPAD('a', NULL, NULL) AS result; -- LPAD",
        "target_query": "SELECT LPAD('a', NULL, NULL) AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_80_5",
        "database_name": "duckdb_80_5",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT LPAD('a', 5, NULL) AS result; -- LPAD",
        "target_query": "SELECT LPAD('a', 5, NULL) AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_80_6",
        "database_name": "duckdb_80_6",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT LPAD(NULL, 5, NULL) AS result; -- LPAD",
        "target_query": "SELECT LPAD(NULL, 5, NULL) AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_80_7",
        "database_name": "duckdb_80_7",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT LPAD('a', 0, 'x') AS result; -- LPAD",
        "target_query": "SELECT LPAD('a', 0, 'x') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_80_8",
        "database_name": "duckdb_80_8",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT LPAD('a', 0, '') AS result; -- LPAD",
        "target_query": "SELECT LPAD('a', 0, '') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_80_9",
        "database_name": "duckdb_80_9",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT LPAD('', 0, 'x') AS result; -- LPAD",
        "target_query": "SELECT LPAD('', 0, 'x') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_80_10",
        "database_name": "duckdb_80_10",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT LPAD('', 0, '') AS result; -- LPAD",
        "target_query": "SELECT LPAD('', 0, '') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_80_11",
        "database_name": "duckdb_80_11",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT LPAD('a', -1, 'x'); -- LPAD",
        "target_query": "SELECT LPAD('a', -1, 'x');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_80_12",
        "database_name": "duckdb_80_12",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT LPAD('123', 5, 'x'); -- LPAD",
        "target_query": "SELECT LPAD('123', 5, 'x');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_80_13",
        "database_name": "duckdb_80_13",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT LPAD('a', 5, 'xy'); -- LPAD",
        "target_query": "SELECT LPAD('a', 5, 'xy');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_80_14",
        "database_name": "duckdb_80_14",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT LPAD(\"I LOVE SQL\", 20, \" \"); -- LPAD",
        "target_query": "SELECT LPAD('I LOVE SQL', 20, ' ');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_80_15",
        "database_name": "duckdb_80_15",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT LPAD(\"I LOVE SQL in the morning\", 20, \" \"); -- LPAD",
        "target_query": "SELECT LPAD('I LOVE SQL in the morning', 20, ' ');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_81_2",
        "database_name": "duckdb_81_2",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "INSERT INTO t1 VALUES(REPEAT('a', 1024), 0), (REPEAT('b', 1024), 1),(REPEAT('c', 1024), 2), (REPEAT('d', 1024), 3),(REPEAT('e', 1024), 4), (REPEAT('f', 1024), 5); -- REPEAT",
        "target_query": "INSERT INTO t1 VALUES(REPEAT('a', 1024), 0), (REPEAT('b', 1024), 1),(REPEAT('c', 1024), 2), (REPEAT('d', 1024), 3),(REPEAT('e', 1024), 4), (REPEAT('f', 1024), 5);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(f1, longtext, )\n(f2, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(f1, VARCHAR, )\n(f2, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_81_15",
        "database_name": "duckdb_81_15",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT SUM(LENGTH(f1)) FROM t1; -- LENGTH",
        "target_query": "SELECT SUM(length(f1)) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "length(str)",
                "description": "Returns the number of bytes in the input string.",
                "examples": [
                    "SELECT length('abc');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(f1, longtext, )\n(f2, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(f1, VARCHAR, )\n(f2, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_82_3",
        "database_name": "duckdb_82_3",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT COALESCE(d, d), IFNULL(d, d), IF(i, d, d),CASE i WHEN i THEN d ELSE d END, GREATEST(d, d), LEAST(d, d)FROM t1 ORDER BY RAND(); -- COALESCE, IFNULL, IF, GREATEST, LEAST",
        "target_query": "SELECT COALESCE(d, d), COALESCE(d, d), CASE WHEN i THEN d ELSE d END, CASE i WHEN i THEN d ELSE d END, GREATEST(d, d), least(d, d) FROM t1 ORDER BY RANDOM();",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "COALESCE",
            "IFNULL",
            "IF",
            "GREATEST",
            "LEAST"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
                "description": "Returns the first non-NULL value, or merges table partitions.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
                    "ALTER TABLE t1 COALESCE PARTITION 2;"
                ]
            },
            {
                "expression": "IFNULL(expr1, expr2)",
                "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
                "examples": [
                    "SELECT IFNULL(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            },
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            },
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            },
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...)",
                "description": "DuckDB supports COALESCE for NULL handling.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;"
                ]
            },
            {
                "expression": "COALESCE(expr1, expr2)",
                "description": "DuckDB also uses COALESCE to return the first non-NULL argument, which is functionally the same as IFNULL in MySQL.",
                "examples": [
                    "SELECT COALESCE(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            },
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "DuckDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It allows you to return different values based on a given condition.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            },
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            },
            {
                "expression": "least(expr1, expr2, ...)",
                "description": "Returns the least non-null value among the provided expressions. NULLs are skipped unless all arguments are NULL. This differs from MySQL/MariaDB which return NULL if any argument is NULL.",
                "examples": [
                    "SELECT least(5, 10, 3);",
                    "SELECT least(DATE '2024-01-01', DATE '2023-12-31');",
                    "SELECT least(NULL, 2);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(i, int, )\n(d, date, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(i, INTEGER, )\n(d, DATE, )\n"
        ]
    },
    {
        "sql_id": "duckdb_83_3",
        "database_name": "duckdb_83_3",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT HEX(c1) FROM AB; -- HEX",
        "target_query": "SELECT HEX(c1) FROM AB;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts numeric or string values into their hexadecimal string representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `AB`\nColumns:\n(c1, char(100), )\n"
        ],
        "target_related_schemas": [
            "Table: `AB`\nColumns:\n(c1, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_84_2",
        "database_name": "duckdb_84_2",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "insert into t5 values (1, date_format('2001-01-01','%W')); -- DATE_FORMAT",
        "target_query": "insert into t5 values (1, STRFTIME(DATE '2001-01-01','%W'));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "DATE_FORMAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_FORMAT(date_expr, format_str)",
                "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
                "examples": [
                    "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
                    "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "STRFTIME(date_expr, format_str)",
                "description": "Formats a date/time value using SQLite-compatible strftime format specifiers.",
                "examples": [
                    "SELECT STRFTIME('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT STRFTIME(CURRENT_TIMESTAMP, '%Y-%m-%d %H:%M:%S');",
                    "SELECT STRFTIME('2023-01-15 12:00:00', '%d-%m-%Y');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t5`\nColumns:\n(c1, int, )\n(c2, varchar(128), )\n"
        ],
        "target_related_schemas": [
            "Table: `t5`\nColumns:\n(c1, INTEGER, )\n(c2, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_84_3",
        "database_name": "duckdb_84_3",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "insert into t5 values (2, date_format('2001-01-01','%W')); -- DATE_FORMAT",
        "target_query": "insert into t5 values (2, STRFTIME(DATE '2001-01-01','%W'));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "DATE_FORMAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_FORMAT(date_expr, format_str)",
                "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
                "examples": [
                    "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
                    "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "STRFTIME(date_expr, format_str)",
                "description": "Formats a date/time value using SQLite-compatible strftime format specifiers.",
                "examples": [
                    "SELECT STRFTIME('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT STRFTIME(CURRENT_TIMESTAMP, '%Y-%m-%d %H:%M:%S');",
                    "SELECT STRFTIME('2023-01-15 12:00:00', '%d-%m-%Y');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t5`\nColumns:\n(c1, int, )\n(c2, varchar(128), )\n"
        ],
        "target_related_schemas": [
            "Table: `t5`\nColumns:\n(c1, INTEGER, )\n(c2, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_84_4",
        "database_name": "duckdb_84_4",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "insert into t5 values (3, date_format('2001-01-01','%W')); -- DATE_FORMAT",
        "target_query": "insert into t5 values (3, STRFTIME(DATE '2001-01-01','%W'));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "DATE_FORMAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_FORMAT(date_expr, format_str)",
                "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
                "examples": [
                    "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
                    "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "STRFTIME(date_expr, format_str)",
                "description": "Formats a date/time value using SQLite-compatible strftime format specifiers.",
                "examples": [
                    "SELECT STRFTIME('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT STRFTIME(CURRENT_TIMESTAMP, '%Y-%m-%d %H:%M:%S');",
                    "SELECT STRFTIME('2023-01-15 12:00:00', '%d-%m-%Y');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t5`\nColumns:\n(c1, int, )\n(c2, varchar(128), )\n"
        ],
        "target_related_schemas": [
            "Table: `t5`\nColumns:\n(c1, INTEGER, )\n(c2, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_84_8",
        "database_name": "duckdb_84_8",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select hex(a) from t1; -- HEX",
        "target_query": "select hex(a) from t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts numeric or string values into their hexadecimal string representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, varchar(64), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_85_2",
        "database_name": "duckdb_85_2",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 123)); -- REPEAT",
        "target_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 123));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, longtext, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_85_3",
        "database_name": "duckdb_85_3",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 234)); -- REPEAT",
        "target_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 234));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, longtext, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_85_4",
        "database_name": "duckdb_85_4",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 345)); -- REPEAT",
        "target_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 345));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, longtext, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_85_5",
        "database_name": "duckdb_85_5",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 456)); -- REPEAT",
        "target_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 456));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, longtext, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_85_6",
        "database_name": "duckdb_85_6",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT LENGTH(c1) FROM t1; -- LENGTH",
        "target_query": "SELECT length(c1) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "length(str)",
                "description": "Returns the number of bytes in the input string.",
                "examples": [
                    "SELECT length('abc');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, longtext, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(c1, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_86_0",
        "database_name": "duckdb_86_0",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select null,isnull(null),isnull(1/0),isnull(1/0 = null),ifnull(null,1),ifnull(null,\"TRUE\"),ifnull(\"TRUE\",\"ERROR\"),1/0 is null,1 is not null; -- ISNULL, IFNULL",
        "target_query": "SELECT NULL, NULL IS NULL, (1/0) IS NULL, (1/0 = NULL) IS NULL, COALESCE(NULL, 1), COALESCE(NULL, 'TRUE'), COALESCE('TRUE', 'ERROR'), (1/0) IS NULL, 1 IS NOT NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ISNULL",
            "IFNULL"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "ISNULL(expr)",
                "description": "Returns 1 if the expression is NULL, otherwise returns 0.",
                "examples": [
                    "SELECT ISNULL(NULL);",
                    "SELECT ISNULL(5 + NULL);",
                    "SELECT IF(ISNULL(score), 'N/A', score) FROM students;"
                ]
            },
            {
                "expression": "IFNULL(expr1, expr2)",
                "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
                "examples": [
                    "SELECT IFNULL(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "expr IS NULL",
                "description": "Tests whether the expression evaluates to NULL.",
                "examples": [
                    "SELECT NULL IS NULL;",
                    "SELECT ('abc' || NULL) IS NULL;",
                    "SELECT CASE WHEN status IS NULL THEN 'unknown' ELSE status END FROM orders;"
                ]
            },
            {
                "expression": "COALESCE(expr1, expr2)",
                "description": "DuckDB also uses COALESCE to return the first non-NULL argument, which is functionally the same as IFNULL in MySQL.",
                "examples": [
                    "SELECT COALESCE(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_86_1",
        "database_name": "duckdb_86_1",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select NULL=NULL,NULL<>NULL,IFNULL(NULL,1.1)+0,IFNULL(NULL,1) | 0; -- IFNULL",
        "target_query": "SELECT NULL = NULL, NULL <> NULL, COALESCE(NULL, 1.1) + 0, COALESCE(NULL, 1) | 0;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IFNULL"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IFNULL(expr1, expr2)",
                "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
                "examples": [
                    "SELECT IFNULL(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2)",
                "description": "DuckDB also uses COALESCE to return the first non-NULL argument, which is functionally the same as IFNULL in MySQL.",
                "examples": [
                    "SELECT COALESCE(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_86_3",
        "database_name": "duckdb_86_3",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select repeat(\"a\",0),repeat(\"ab\",5+5),repeat(\"ab\",-1),reverse(NULL); -- REPEAT",
        "target_query": "SELECT REPEAT('a', 0), REPEAT('ab', 5 + 5), REPEAT('ab', -1), REVERSE(NULL);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_86_4",
        "database_name": "duckdb_86_4",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select field(NULL,\"a\",\"b\",\"c\"); -- FIELD",
        "target_query": "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], NULL), 0);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "FIELD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "FIELD(val, val1, val2, ..., valN)",
                "description": "Returns the index (1-based) of the first value in the list that is equal to 'val'. Returns 0 if no match is found.",
                "examples": [
                    "SELECT FIELD('c', 'a', 'b', 'c') AS result;",
                    "SELECT FIELD('x', 'a', 'b', 'c') AS result;",
                    "SELECT FIELD('b', 'b', 'b', 'b') AS result;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(array_position(ARRAY[val1, val2, ..., valN], val), 0)",
                "description": "Returns the index (1-based) of 'val' in the array. Returns 0 if not found, emulating MySQL FIELD().",
                "examples": [
                    "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'c'), 0) AS result;",
                    "SELECT COALESCE(array_position(ARRAY['a', 'b', 'c'], 'x'), 0) AS result;",
                    "SELECT COALESCE(array_position(ARRAY['b', 'b', 'b'], 'b'), 0) AS result;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_86_9",
        "database_name": "duckdb_86_9",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "CREATE TABLE t2 SELECT IFNULL(a, b) FROM t1; -- IFNULL",
        "target_query": "CREATE TABLE t2 AS SELECT COALESCE(a, b) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IFNULL"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IFNULL(expr1, expr2)",
                "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
                "examples": [
                    "SELECT IFNULL(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2)",
                "description": "DuckDB also uses COALESCE to return the first non-NULL argument, which is functionally the same as IFNULL in MySQL.",
                "examples": [
                    "SELECT COALESCE(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, decimal(1,0), )\n(b, decimal(1,0), )\n",
            "Table: `t2`\nColumns:\n(IFNULL(a, b), decimal(1,0), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, DECIMAL(1,0), )\n(b, DECIMAL(1,0), )\n",
            "Table: `t2`\nColumns:\n(COALESCE(a, b), DECIMAL(1,0), )\n"
        ]
    },
    {
        "sql_id": "duckdb_86_11",
        "database_name": "duckdb_86_11",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "CREATE TABLE t2 SELECT IFNULL(a, NULL) FROM t1; -- IFNULL",
        "target_query": "CREATE TABLE t2 AS SELECT COALESCE(a, NULL) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IFNULL"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IFNULL(expr1, expr2)",
                "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
                "examples": [
                    "SELECT IFNULL(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2)",
                "description": "DuckDB also uses COALESCE to return the first non-NULL argument, which is functionally the same as IFNULL in MySQL.",
                "examples": [
                    "SELECT COALESCE(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, decimal(1,0), )\n(b, decimal(1,0), )\n",
            "Table: `t2`\nColumns:\n(IFNULL(a, NULL), decimal(1,0), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, DECIMAL(1,0), )\n(b, DECIMAL(1,0), )\n",
            "Table: `t2`\nColumns:\n(COALESCE(a, NULL), DECIMAL(1,0), )\n"
        ]
    },
    {
        "sql_id": "duckdb_86_13",
        "database_name": "duckdb_86_13",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "CREATE TABLE t2 SELECT IFNULL(NULL, b) FROM t1; -- IFNULL",
        "target_query": "CREATE TABLE t2 AS SELECT COALESCE(NULL, b) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IFNULL"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IFNULL(expr1, expr2)",
                "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
                "examples": [
                    "SELECT IFNULL(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2)",
                "description": "DuckDB also uses COALESCE to return the first non-NULL argument, which is functionally the same as IFNULL in MySQL.",
                "examples": [
                    "SELECT COALESCE(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, decimal(1,0), )\n(b, decimal(1,0), )\n",
            "Table: `t2`\nColumns:\n(IFNULL(NULL, b), decimal(1,0), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, DECIMAL(1,0), )\n(b, DECIMAL(1,0), )\n",
            "Table: `t2`\nColumns:\n(COALESCE(NULL, b), DECIMAL(1,0), )\n"
        ]
    },
    {
        "sql_id": "duckdb_87_2",
        "database_name": "duckdb_87_2",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "INSERT INTO t1 VALUES ( repeat( 'a', 10 ), 1),( repeat( 'b', 10 ), 2); -- REPEAT",
        "target_query": "INSERT INTO t1 VALUES ( repeat( 'a', 10 ), 1),( repeat( 'b', 10 ), 2);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, varchar(10), )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, VARCHAR, )\n(b, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_87_3",
        "database_name": "duckdb_87_3",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT GROUP_CONCAT(a) FROM t1; -- GROUP_CONCAT",
        "target_query": "SELECT GROUP_CONCAT(a) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "GROUP_CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
                "description": "The GROUP_CONCAT([DISTINCT] expr [,expr ...]  [ORDER BY {unsigned_integer | col_name | expr}  [ASC | DESC] [,col_name ...]]  [SEPARATOR str_val])\nfunction returns a string result with the concatenated non-NULL values from a group.\nDISTINGUISHED keyword can be used to eliminate duplicate values.\nORDER BY clause can be used to sort the values.\nSEPARATOR keyword specifies the separator between values, default is comma(,).\nThe maximum length of the result is controlled by group_concat_max_len system variable, default is 1024.",
                "examples": [
                    "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
                    "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
                "description": "The GROUP_CONCAT function in DuckDB concatenates values from multiple rows into a single string, separated by a specified delimiter.",
                "examples": [
                    "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
                    "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, varchar(10), )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, VARCHAR, )\n(b, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_87_5",
        "database_name": "duckdb_87_5",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT UNIX_TIMESTAMP(); -- UNIX_TIMESTAMP",
        "target_query": "SELECT EXTRACT(EPOCH FROM current_timestamp);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UNIX_TIMESTAMP"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_88_0",
        "database_name": "duckdb_88_0",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select repeat('a',2000); -- REPEAT",
        "target_query": "SELECT REPEAT('a',2000);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_88_1",
        "database_name": "duckdb_88_1",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT length(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\") as len; -- LENGTH",
        "target_query": "SELECT length('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa') AS len;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "length(str)",
                "description": "Returns the number of bytes in the input string.",
                "examples": [
                    "SELECT length('abc');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_88_2",
        "database_name": "duckdb_88_2",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select length(repeat('a',2000)); -- LENGTH, REPEAT",
        "target_query": "SELECT length(REPEAT('a',2000));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH",
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            },
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "length(str)",
                "description": "Returns the number of bytes in the input string.",
                "examples": [
                    "SELECT length('abc');"
                ]
            },
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_88_9",
        "database_name": "duckdb_88_9",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT c11, LENGTH(c12) FROM t1; -- LENGTH",
        "target_query": "SELECT c11, length(c12) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "length(str)",
                "description": "Returns the number of bytes in the input string.",
                "examples": [
                    "SELECT length('abc');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(c11, int, )\n(c12, longtext, )\n",
            "Table: `t2`\nColumns:\n(c21, int, )\n(c22, longtext, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(c11, INTEGER, )\n(c12, VARCHAR, )\n",
            "Table: `t2`\nColumns:\n(c21, INTEGER, )\n(c22, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_89_3",
        "database_name": "duckdb_89_3",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select hex(a) from t1 where a like 'A_'; -- HEX",
        "target_query": "select hex(a) from t1 where a like 'A_';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts numeric or string values into their hexadecimal string representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, varchar(50), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_89_5",
        "database_name": "duckdb_89_5",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "explain select hex(a) from t1 where a like 'A_'; -- HEX",
        "target_query": "explain select hex(a) from t1 where a like 'A_';",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts numeric or string values into their hexadecimal string representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, varchar(50), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_89_6",
        "database_name": "duckdb_89_6",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select hex(a) from t1; -- HEX",
        "target_query": "select hex(a) from t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "HEX"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts numeric or string values into their hexadecimal string representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, varchar(50), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_89_8",
        "database_name": "duckdb_89_8",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "create table t1 as select to_seconds(null) as to_seconds; -- TO_SECONDS",
        "target_query": "create table t1 as select epoch(NULL::TIMESTAMP) + 62167219200 as to_seconds;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TO_SECONDS"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TO_SECONDS(datetime_expr)",
                "description": "Returns the number of seconds since year 0 to the given datetime.",
                "examples": [
                    "SELECT TO_SECONDS('2000-01-01 00:00:00');",
                    "SELECT TO_SECONDS(NOW());",
                    "SELECT TO_SECONDS(NULL);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "epoch(ts) + 62167219200",
                "description": "Converts timestamp to Unix epoch time and adds the number of seconds between year 0 and 1970.",
                "examples": [
                    "SELECT epoch(TIMESTAMP '2020-12-31 12:00:00') + 62167219200;",
                    "SELECT epoch(CURRENT_TIMESTAMP) + 62167219200;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(to_seconds, bigint, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(to_seconds, DOUBLE, )\n"
        ]
    },
    {
        "sql_id": "duckdb_9_0",
        "database_name": "duckdb_9_0",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT IF(0,\"ERROR\",\"this\"),IF(1,\"is\",\"ERROR\"),IF(NULL,\"ERROR\",\"a\"),IF(1,2,3),IF(1,2.0,3.0)+0; -- IF",
        "target_query": "SELECT CASE WHEN 0 THEN 'ERROR' ELSE 'this' END, CASE WHEN 1 THEN 'is' ELSE 'ERROR' END, CASE WHEN NULL THEN 'ERROR' ELSE 'a' END, CASE WHEN 1 THEN 2 ELSE 3 END, CASE WHEN 1 THEN 2.0 ELSE 3.0 END + 0;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "DuckDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It allows you to return different values based on a given condition.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_9_4",
        "database_name": "duckdb_9_4",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT IF(1,st,st) s FROM t1 ORDER BY s; -- IF",
        "target_query": "SELECT CASE WHEN 1 THEN st ELSE st END s FROM t1 ORDER BY s;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "DuckDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It allows you to return different values based on a given condition.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(st, varchar(255), )\n(u, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(st, VARCHAR, )\n(u, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_9_5",
        "database_name": "duckdb_9_5",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT IF(u=1,st,st) s FROM t1 ORDER BY s; -- IF",
        "target_query": "SELECT CASE WHEN u=1 THEN st ELSE st END s FROM t1 ORDER BY s;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "DuckDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It allows you to return different values based on a given condition.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(st, varchar(255), )\n(u, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(st, VARCHAR, )\n(u, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_9_7",
        "database_name": "duckdb_9_7",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select nullif(u, 1) from t1; -- NULLIF",
        "target_query": "SELECT NULLIF(u, 1) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "NULLIF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "NULLIF(a, b)",
                "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
                "examples": [
                    "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
                    "SELECT NULLIF(YEAR('2021-01-01'), 2021) AS year_check;",
                    "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "NULLIF(a, b)",
                "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
                "examples": [
                    "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
                    "SELECT NULLIF(EXTRACT(YEAR FROM DATE '2021-01-01'), 2021) AS year_check;",
                    "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(st, varchar(255), )\n(u, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(st, VARCHAR, )\n(u, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_9_8",
        "database_name": "duckdb_9_8",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "explain select nullif(u, 1) from t1; -- NULLIF",
        "target_query": "EXPLAIN SELECT NULLIF(u, 1) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "NULLIF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "NULLIF(a, b)",
                "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
                "examples": [
                    "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
                    "SELECT NULLIF(YEAR('2021-01-01'), 2021) AS year_check;",
                    "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "NULLIF(a, b)",
                "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
                "examples": [
                    "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
                    "SELECT NULLIF(EXTRACT(YEAR FROM DATE '2021-01-01'), 2021) AS year_check;",
                    "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(st, varchar(255), )\n(u, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(st, VARCHAR, )\n(u, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_9_12",
        "database_name": "duckdb_9_12",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select sum(if(num is null,0.00,num)) from t1; -- IF",
        "target_query": "SELECT SUM(CASE WHEN num IS NULL THEN 0.00 ELSE num END) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "DuckDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It allows you to return different values based on a given condition.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(num, double(12,2), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(num, DOUBLE, )\n"
        ]
    },
    {
        "sql_id": "duckdb_9_16",
        "database_name": "duckdb_9_16",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select min(if(y -x > 5,y,NULL)), max(if(y - x > 5,y,NULL)) from t1; -- IF",
        "target_query": "SELECT MIN(CASE WHEN y - x > 5 THEN y ELSE NULL END), MAX(CASE WHEN y - x > 5 THEN y ELSE NULL END) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "DuckDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It allows you to return different values based on a given condition.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(x, int, )\n(y, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(x, INTEGER, )\n(y, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_9_18",
        "database_name": "duckdb_9_18",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT NULLIF(5,5) IS NULL, NULLIF(5,5) IS NOT NULL; -- NULLIF",
        "target_query": "SELECT NULLIF(5,5) IS NULL, NULLIF(5,5) IS NOT NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "NULLIF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "NULLIF(a, b)",
                "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
                "examples": [
                    "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
                    "SELECT NULLIF(YEAR('2021-01-01'), 2021) AS year_check;",
                    "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "NULLIF(a, b)",
                "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
                "examples": [
                    "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
                    "SELECT NULLIF(EXTRACT(YEAR FROM DATE '2021-01-01'), 2021) AS year_check;",
                    "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_9_21",
        "database_name": "duckdb_9_21",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT id, IF(date IS NULL, '-', FROM_UNIXTIME(date, '%d-%m-%Y')) AS date_ord, text FROM t1 ORDER BY date_ord ASC; -- IF, FROM_UNIXTIME",
        "target_query": "SELECT id, CASE WHEN date IS NULL THEN '-' ELSE STRFTIME(TO_TIMESTAMP(date), '%d-%m-%Y') END AS date_ord, text FROM t1 ORDER BY date_ord ASC;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IF",
            "FROM_UNIXTIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            },
            {
                "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
                "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
                "examples": [
                    "SELECT FROM_UNIXTIME(1672531200);",
                    "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
                    "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "DuckDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It allows you to return different values based on a given condition.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            },
            {
                "expression": "TO_TIMESTAMP(unix_timestamp)",
                "description": "Converts a Unix timestamp (seconds since epoch) to a TIMESTAMP value.",
                "examples": [
                    "SELECT TO_TIMESTAMP(1672531200);",
                    "SELECT TO_TIMESTAMP(1672531200.789);",
                    "SELECT id, TO_TIMESTAMP(event_time) AS event_ts FROM events;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(id, int, )\n(date, int, )\n(text, varchar(32), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(id, INTEGER, )\n(date, INTEGER, )\n(text, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_9_22",
        "database_name": "duckdb_9_22",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT id, IF(date IS NULL, '-', FROM_UNIXTIME(date, '%d-%m-%Y')) AS date_ord, text FROM t1 ORDER BY date_ord DESC; -- IF, FROM_UNIXTIME",
        "target_query": "SELECT id, CASE WHEN date IS NULL THEN '-' ELSE STRFTIME(TO_TIMESTAMP(date), '%d-%m-%Y') END AS date_ord, text FROM t1 ORDER BY date_ord DESC;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IF",
            "FROM_UNIXTIME"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            },
            {
                "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
                "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
                "examples": [
                    "SELECT FROM_UNIXTIME(1672531200);",
                    "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
                    "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "DuckDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It allows you to return different values based on a given condition.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            },
            {
                "expression": "TO_TIMESTAMP(unix_timestamp)",
                "description": "Converts a Unix timestamp (seconds since epoch) to a TIMESTAMP value.",
                "examples": [
                    "SELECT TO_TIMESTAMP(1672531200);",
                    "SELECT TO_TIMESTAMP(1672531200.789);",
                    "SELECT id, TO_TIMESTAMP(event_time) AS event_ts FROM events;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(id, int, )\n(date, int, )\n(text, varchar(32), )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(id, INTEGER, )\n(date, INTEGER, )\n(text, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_9_26",
        "database_name": "duckdb_9_26",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT * FROM (SELECT MAX(IF(1, CAST(c AS UNSIGNED), 0)) FROM t1) AS te; -- IF",
        "target_query": "SELECT * FROM (SELECT MAX(CASE WHEN 1 THEN CAST(c AS INT64) ELSE 0 END) FROM t1) AS te;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IF"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "DuckDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It allows you to return different values based on a given condition.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(c, longtext, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(c, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_9_27",
        "database_name": "duckdb_9_27",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT * FROM (SELECT MAX(IFNULL(CAST(c AS UNSIGNED), 0)) FROM t1) AS te; -- IFNULL",
        "target_query": "SELECT * FROM (SELECT MAX(COALESCE(CAST(c AS INT64), 0)) FROM t1) AS te;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IFNULL"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IFNULL(expr1, expr2)",
                "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
                "examples": [
                    "SELECT IFNULL(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2)",
                "description": "DuckDB also uses COALESCE to return the first non-NULL argument, which is functionally the same as IFNULL in MySQL.",
                "examples": [
                    "SELECT COALESCE(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(c, longtext, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(c, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_9_29",
        "database_name": "duckdb_9_29",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT AVG(NULLIF(YEAR('2001-01-01'),10)); -- NULLIF, YEAR",
        "target_query": "SELECT AVG(NULLIF(EXTRACT(YEAR FROM DATE '2001-01-01'),10));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "NULLIF",
            "YEAR"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "NULLIF(a, b)",
                "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
                "examples": [
                    "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
                    "SELECT NULLIF(YEAR('2021-01-01'), 2021) AS year_check;",
                    "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
                ]
            },
            {
                "expression": "YEAR(date)",
                "description": "Extracts the year from a date or datetime and returns it as an integer.",
                "examples": [
                    "SELECT YEAR('2023-04-10');",
                    "SELECT YEAR(NOW());",
                    "SELECT YEAR('2022-03-15');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "NULLIF(a, b)",
                "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
                "examples": [
                    "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
                    "SELECT NULLIF(EXTRACT(YEAR FROM DATE '2021-01-01'), 2021) AS year_check;",
                    "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
                ]
            },
            {
                "expression": "EXTRACT(YEAR FROM date)",
                "description": "Extracts the year from a date or datetime and returns it as an integer.",
                "examples": [
                    "SELECT EXTRACT(YEAR FROM DATE '2023-04-10');",
                    "SELECT EXTRACT(YEAR FROM CURRENT_DATE);",
                    "SELECT EXTRACT(YEAR FROM DATE '2022-03-15');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_90_0",
        "database_name": "duckdb_90_0",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT FROM_DAYS(3652499), FROM_DAYS(3652500), FROM_DAYS(3652501); -- FROM_DAYS",
        "target_query": "SELECT DATE '0000-01-01' + INTERVAL 3652499 DAY, DATE '0000-01-01' + INTERVAL 3652500 DAY, DATE '0000-01-01' + INTERVAL 3652501 DAY;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "FROM_DAYS"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "FROM_DAYS(n)",
                "description": "Returns a date corresponding to the number of days since year 0.",
                "examples": [
                    "SELECT FROM_DAYS(1);",
                    "SELECT FROM_DAYS(730000);",
                    "SELECT CONCAT('Date is: ', FROM_DAYS(738000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "DATE '0000-01-01' + INTERVAL n DAY",
                "description": "Returns a date by adding n days as an interval to '0000-01-01'.",
                "examples": [
                    "SELECT DATE '0000-01-01' + INTERVAL 1 DAY;",
                    "SELECT DATE '0000-01-01' + INTERVAL 730000 DAY;",
                    "SELECT 'Date is: ' || (DATE '0000-01-01' + INTERVAL 738000 DAY);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_90_1",
        "database_name": "duckdb_90_1",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT FROM_DAYS(42949670), FROM_DAYS(42949671), FROM_DAYS(42949673); -- FROM_DAYS",
        "target_query": "SELECT DATE '0000-01-01' + INTERVAL 42949670 DAY, DATE '0000-01-01' + INTERVAL 42949671 DAY, DATE '0000-01-01' + INTERVAL 42949673 DAY;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "FROM_DAYS"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "FROM_DAYS(n)",
                "description": "Returns a date corresponding to the number of days since year 0.",
                "examples": [
                    "SELECT FROM_DAYS(1);",
                    "SELECT FROM_DAYS(730000);",
                    "SELECT CONCAT('Date is: ', FROM_DAYS(738000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "DATE '0000-01-01' + INTERVAL n DAY",
                "description": "Returns a date by adding n days as an interval to '0000-01-01'.",
                "examples": [
                    "SELECT DATE '0000-01-01' + INTERVAL 1 DAY;",
                    "SELECT DATE '0000-01-01' + INTERVAL 730000 DAY;",
                    "SELECT 'Date is: ' || (DATE '0000-01-01' + INTERVAL 738000 DAY);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_91_2",
        "database_name": "duckdb_91_2",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "INSERT INTO t VALUES (0, REPEAT('x', 120000)), (1, REPEAT('z', 12000)); -- REPEAT",
        "target_query": "INSERT INTO t VALUES (0, REPEAT('x', 120000)), (1, REPEAT('z', 12000));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "REPEAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. NULLs are preserved.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t`\nColumns:\n(i, int, )\n(b, longtext, )\n"
        ],
        "target_related_schemas": [
            "Table: `t`\nColumns:\n(i, INTEGER, )\n(b, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_91_4",
        "database_name": "duckdb_91_4",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT LENGTH(b) FROM (SELECT * FROM t INTERSECT SELECT * FROM t) derived; -- LENGTH",
        "target_query": "SELECT length(b) FROM (SELECT * FROM t INTERSECT SELECT * FROM t) derived;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "LENGTH"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "length(str)",
                "description": "Returns the number of bytes in the input string.",
                "examples": [
                    "SELECT length('abc');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t`\nColumns:\n(i, int, )\n(b, longtext, )\n"
        ],
        "target_related_schemas": [
            "Table: `t`\nColumns:\n(i, INTEGER, )\n(b, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_92_2",
        "database_name": "duckdb_92_2",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT argument FROM test_log WHERE argument LIKE CONCAT('%azun','dris%'); -- CONCAT",
        "target_query": "SELECT argument FROM test_log WHERE argument LIKE CONCAT('%azun', 'dris%');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "CONCAT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ...) or str1 || str2 || ...",
                "description": "Concatenates string expressions into one. Supports both CONCAT() function and || operator. Preserves NULL propagation.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT 'Year: ' || 2025;",
                    "SELECT name || '_' || id FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `test_log`\nColumns:\n(argument, text, )\n"
        ],
        "target_related_schemas": [
            "Table: `test_log`\nColumns:\n(argument, VARCHAR, )\n"
        ]
    },
    {
        "sql_id": "duckdb_93_0",
        "database_name": "duckdb_93_0",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select row(10,2,3) IN (row(3,2,3), row(1,2,3), row(1,3,3)); -- ROW",
        "target_query": "select row(10,2,3) IN (row(3,2,3), row(1,2,3), row(1,3,3));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_93_1",
        "database_name": "duckdb_93_1",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select row(1,2,3) IN (row(3,NULL,3), row(1,2,3), row(1,3,3)); -- ROW",
        "target_query": "select row(1,2,3) IN (row(3,NULL,3), row(1,2,3), row(1,3,3));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_93_2",
        "database_name": "duckdb_93_2",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select row(10,2,3) IN (row(3,NULL,3), row(1,2,3), row(1,3,3)); -- ROW",
        "target_query": "select row(10,2,3) IN (row(3,NULL,3), row(1,2,3), row(1,3,3));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_93_3",
        "database_name": "duckdb_93_3",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select row('a',1.5,3) IN (row(1,2,3), row('a',1.5,3), row('a','a','a')); -- ROW",
        "target_query": "select row('a',1.5,3) IN (row(1,2,3), row('a',1.5,3), row('a','a','a'));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_93_4",
        "database_name": "duckdb_93_4",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select row('a',0,3) IN (row(3,2,3), row('a','a','3'), row(1,3,3)); -- ROW",
        "target_query": "select row('a',0,3) IN (row(3,2,3), row('a','a','3'), row(1,3,3));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_93_5",
        "database_name": "duckdb_93_5",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select row('a',0,3) IN (row(3,2,3), row('a','0','3'), row(1,3,3)); -- ROW",
        "target_query": "select row('a',0,3) IN (row(3,2,3), row('a','0','3'), row(1,3,3));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_93_6",
        "database_name": "duckdb_93_6",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select row('a',1.5,3) IN (row(3,NULL,3), row('a',1.5,3), row(1,3,3)); -- ROW",
        "target_query": "select row('a',1.5,3) IN (row(3,NULL,3), row('a',1.5,3), row(1,3,3));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_93_7",
        "database_name": "duckdb_93_7",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select row('b',1.5,3) IN (row(3,NULL,3), row('a',1.5,3), row(1,3,3)); -- ROW",
        "target_query": "select row('b',1.5,3) IN (row(3,NULL,3), row('a',1.5,3), row(1,3,3));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_93_8",
        "database_name": "duckdb_93_8",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select row('b',1.5,3) IN (row('b',NULL,3), row('a',1.5,3), row(1,3,3)); -- ROW",
        "target_query": "select row('b',1.5,3) IN (row('b',NULL,3), row('a',1.5,3), row(1,3,3));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_93_9",
        "database_name": "duckdb_93_9",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select row('b',1.5,3) IN (row('b',NULL,4), row('a',1.5,3), row(1,3,3)); -- ROW",
        "target_query": "select row('b',1.5,3) IN (row('b',NULL,4), row('a',1.5,3), row(1,3,3));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_93_10",
        "database_name": "duckdb_93_10",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select row(1,2,row(3,4)) IN (row(3,2,row(3,4)), row(1,2,row(3,NULL))); -- ROW",
        "target_query": "select row(1,2,row(3,4)) IN (row(3,2,row(3,4)), row(1,2,row(3,NULL)));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_93_11",
        "database_name": "duckdb_93_11",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "explain select row(1,2,row(3,4)) IN (row(3,2,row(3,4)), row(1,2,row(3,NULL))); -- ROW",
        "target_query": "explain select row(1,2,row(3,4)) IN (row(3,2,row(3,4)), row(1,2,row(3,NULL)));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_93_12",
        "database_name": "duckdb_93_12",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select row(1,2,row(3,null)) IN (row(3,2,row(3,4)), row(1,2,row(4,5))); -- ROW",
        "target_query": "select row(1,2,row(3,null)) IN (row(3,2,row(3,4)), row(1,2,row(4,5)));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_93_13",
        "database_name": "duckdb_93_13",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select row(1,2,row(3,null)) IN (row(3,2,row(3,4)), row(1,2,row(3,5))); -- ROW",
        "target_query": "select row(1,2,row(3,null)) IN (row(3,2,row(3,4)), row(1,2,row(3,5)));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_93_14",
        "database_name": "duckdb_93_14",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT ROW(1,2,3)=ROW(1,2,3); -- ROW",
        "target_query": "SELECT ROW(1,2,3)=ROW(1,2,3);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_93_15",
        "database_name": "duckdb_93_15",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT ROW(2,2,3)=ROW(1+1,2,3); -- ROW",
        "target_query": "SELECT ROW(2,2,3)=ROW(1+1,2,3);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_93_16",
        "database_name": "duckdb_93_16",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT ROW(1,2,3)=ROW(1+1,2,3); -- ROW",
        "target_query": "SELECT ROW(1,2,3)=ROW(1+1,2,3);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_93_17",
        "database_name": "duckdb_93_17",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT ROW(1,2,3)<ROW(1+1,2,3); -- ROW",
        "target_query": "SELECT ROW(1,2,3)<ROW(1+1,2,3);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_93_18",
        "database_name": "duckdb_93_18",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT ROW(1,2,3)>ROW(1+1,2,3); -- ROW",
        "target_query": "SELECT ROW(1,2,3)>ROW(1+1,2,3);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_93_19",
        "database_name": "duckdb_93_19",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT ROW(1,2,3)<=ROW(1+1,2,3); -- ROW",
        "target_query": "SELECT ROW(1,2,3)<=ROW(1+1,2,3);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_93_20",
        "database_name": "duckdb_93_20",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT ROW(1,2,3)>=ROW(1+1,2,3); -- ROW",
        "target_query": "SELECT ROW(1,2,3)>=ROW(1+1,2,3);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_93_21",
        "database_name": "duckdb_93_21",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT ROW(1,2,3)<>ROW(1+1,2,3); -- ROW",
        "target_query": "SELECT ROW(1,2,3)<>ROW(1+1,2,3);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_93_22",
        "database_name": "duckdb_93_22",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT ROW(NULL,2,3)=ROW(NULL,2,3); -- ROW",
        "target_query": "SELECT ROW(NULL,2,3)=ROW(NULL,2,3);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_93_23",
        "database_name": "duckdb_93_23",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT ROW(1,2,ROW(3,4,5))=ROW(1,2,ROW(3,4,5)); -- ROW",
        "target_query": "SELECT ROW(1,2,ROW(3,4,5))=ROW(1,2,ROW(3,4,5));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_93_24",
        "database_name": "duckdb_93_24",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT ROW('test',2,3.33)=ROW('test',2,3.33); -- ROW",
        "target_query": "SELECT ROW('test',2,3.33)=ROW('test',2,3.33);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_93_25",
        "database_name": "duckdb_93_25",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT ROW('test',2,ROW(3,33))=ROW('test',2,ROW(3,33)); -- ROW",
        "target_query": "SELECT ROW('test',2,ROW(3,33))=ROW('test',2,ROW(3,33));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_93_26",
        "database_name": "duckdb_93_26",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT ROW('test',2,ROW(3,33))=ROW('test',2,ROW(3,3)); -- ROW",
        "target_query": "SELECT ROW('test',2,ROW(3,33))=ROW('test',2,ROW(3,3));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_93_27",
        "database_name": "duckdb_93_27",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT ROW('test',2,ROW(3,33))=ROW('test',2,ROW(3,NULL)); -- ROW",
        "target_query": "SELECT ROW('test',2,ROW(3,33))=ROW('test',2,ROW(3,NULL));",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_94_3",
        "database_name": "duckdb_94_3",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select * from t1 where ROW(1,2,3)=ROW(a,b,c); -- ROW",
        "target_query": "SELECT * FROM t1 WHERE ROW(1,2,3) = ROW(a,b,c);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, int, )\n(c, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, INTEGER, )\n(b, INTEGER, )\n(c, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_94_4",
        "database_name": "duckdb_94_4",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select * from t1 where ROW(0,2,3)=ROW(a,b,c); -- ROW",
        "target_query": "SELECT * FROM t1 WHERE ROW(0,2,3) = ROW(a,b,c);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, int, )\n(c, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, INTEGER, )\n(b, INTEGER, )\n(c, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_94_5",
        "database_name": "duckdb_94_5",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select * from t1 where ROW(1,2,3)<ROW(a,b,c); -- ROW",
        "target_query": "SELECT * FROM t1 WHERE ROW(1,2,3) < ROW(a,b,c);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, int, )\n(c, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, INTEGER, )\n(b, INTEGER, )\n(c, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_94_6",
        "database_name": "duckdb_94_6",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select ROW(a,2,3) IN(row(1,b,c), row(2,3,1)) from t1; -- ROW",
        "target_query": "SELECT ROW(a,2,3) IN (ROW(1,b,c), ROW(2,3,1)) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, int, )\n(c, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, INTEGER, )\n(b, INTEGER, )\n(c, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_94_7",
        "database_name": "duckdb_94_7",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select ROW(c,2,3) IN(row(1,b,a), row(2,3,1)) from t1; -- ROW",
        "target_query": "SELECT ROW(c,2,3) IN (ROW(1,b,a), ROW(2,3,1)) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, int, )\n(c, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, INTEGER, )\n(b, INTEGER, )\n(c, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_94_8",
        "database_name": "duckdb_94_8",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select ROW(a,b,c) IN(row(1,2,3), row(3,2,1)) from t1; -- ROW",
        "target_query": "SELECT ROW(a,b,c) IN (ROW(1,2,3), ROW(3,2,1)) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, int, )\n(c, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, INTEGER, )\n(b, INTEGER, )\n(c, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_94_9",
        "database_name": "duckdb_94_9",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "select ROW(1,2,3) IN(row(a,b,c), row(1,2,3)) from t1; -- ROW",
        "target_query": "SELECT ROW(1,2,3) IN (ROW(a,b,c), ROW(1,2,3)) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, int, )\n(c, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, INTEGER, )\n(b, INTEGER, )\n(c, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_94_11",
        "database_name": "duckdb_94_11",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT ROW(1,1,1) = ROW(1,1,1), ROW(1,1,1) = ROW(1,2,1), ROW(1,NULL,1) = ROW(2,2,1), ROW(1,NULL,1) = ROW(1,2,2), ROW(1,NULL,1) = ROW(1,2,1) ; -- ROW",
        "target_query": "SELECT ROW(1,1,1) = ROW(1,1,1), ROW(1,1,1) = ROW(1,2,1), ROW(1,NULL,1) = ROW(2,2,1), ROW(1,NULL,1) = ROW(1,2,2), ROW(1,NULL,1) = ROW(1,2,1);",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_95_3",
        "database_name": "duckdb_95_3",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT ROW(a, 1) IN (SELECT SUM(b), 1) FROM t1 GROUP BY a; -- ROW",
        "target_query": "SELECT ROW(a, 1) IN (SELECT ROW(SUM(b), 1)) FROM t1 GROUP BY a;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, INTEGER, )\n(b, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_95_4",
        "database_name": "duckdb_95_4",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT ROW(a, 1) IN (SELECT SUM(b), 3) FROM t1 GROUP BY a; -- ROW",
        "target_query": "SELECT ROW(a, 1) IN (SELECT ROW(SUM(b), 3)) FROM t1 GROUP BY a;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, INTEGER, )\n(b, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_95_12",
        "database_name": "duckdb_95_12",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT ROW(1,2) = (SELECT 1,2 FROM t1 WHERE 1 = 0); -- ROW",
        "target_query": "SELECT ROW(1,2) = ROW((SELECT 1), (SELECT 2)) FROM t1 WHERE 1 = 0;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(i, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(i, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_95_13",
        "database_name": "duckdb_95_13",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT ROW(1,2) = (SELECT 1,3 FROM t1 WHERE 1 = 0); -- ROW",
        "target_query": "SELECT ROW(1,2) = ROW((SELECT 1), (SELECT 3)) FROM t1 WHERE 1 = 0;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(i, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(i, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_95_18",
        "database_name": "duckdb_95_18",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "EXPLAIN SELECT row( min(a), 1 ) = row( a, 1 ) AS al FROM t1 GROUP BY a; -- ROW",
        "target_query": "EXPLAIN SELECT ROW(MIN(a), 1) = ROW(a, 1) AS al FROM t1 GROUP BY a;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_95_19",
        "database_name": "duckdb_95_19",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT row( min(a), 1 ) = row( a, 1 ) AS al FROM t1 GROUP BY a; -- ROW",
        "target_query": "SELECT ROW(MIN(a), 1) = ROW(a, 1) AS al FROM t1 GROUP BY a;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ROW"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "ROW is used to represent a group of values as a tuple, which can then be used in comparisons such as IN or equality checks.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT ROW(10, 2, 3) IN (ROW(3, 2, 3), ROW(1, 2, 3), ROW(1, 3, 3));",
                "description": "DuckDB supports ROW, but subqueries must return only one column for the comparison to work.",
                "examples": [
                    "SELECT ROW(1, 2) IN (ROW(1, 2), ROW(3, 4));",
                    "SELECT ROW(10, 20) = ROW(5, 15);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_96_0",
        "database_name": "duckdb_96_0",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT RPAD(NULL, 5, 'x') AS result; -- RPAD",
        "target_query": "SELECT RPAD(NULL, 5, 'x') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "RPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "DuckDB supports RPAD for string padding.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123::TEXT, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_96_1",
        "database_name": "duckdb_96_1",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT RPAD(NULL, NULL, 'x') AS result; -- RPAD",
        "target_query": "SELECT RPAD(NULL, NULL, 'x') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "RPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "DuckDB supports RPAD for string padding.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123::TEXT, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_96_2",
        "database_name": "duckdb_96_2",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT RPAD(NULL, NULL, NULL) AS result; -- RPAD",
        "target_query": "SELECT RPAD(NULL, NULL, NULL) AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "RPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "DuckDB supports RPAD for string padding.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123::TEXT, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_96_3",
        "database_name": "duckdb_96_3",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT RPAD('a', NULL, 'x') AS result; -- RPAD",
        "target_query": "SELECT RPAD('a', NULL, 'x') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "RPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "DuckDB supports RPAD for string padding.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123::TEXT, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_96_4",
        "database_name": "duckdb_96_4",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT RPAD('a', NULL, NULL) AS result; -- RPAD",
        "target_query": "SELECT RPAD('a', NULL, NULL) AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "RPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "DuckDB supports RPAD for string padding.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123::TEXT, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_96_5",
        "database_name": "duckdb_96_5",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT RPAD('a', 5, NULL) AS result; -- RPAD",
        "target_query": "SELECT RPAD('a', 5, NULL) AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "RPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "DuckDB supports RPAD for string padding.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123::TEXT, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_96_6",
        "database_name": "duckdb_96_6",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT RPAD(NULL, 5, NULL) AS result; -- RPAD",
        "target_query": "SELECT RPAD(NULL, 5, NULL) AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "RPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "DuckDB supports RPAD for string padding.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123::TEXT, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_96_7",
        "database_name": "duckdb_96_7",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT RPAD('a', 0, 'x') AS result; -- RPAD",
        "target_query": "SELECT RPAD('a', 0, 'x') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "RPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "DuckDB supports RPAD for string padding.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123::TEXT, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_96_8",
        "database_name": "duckdb_96_8",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT RPAD('a', 0, '') AS result; -- RPAD",
        "target_query": "SELECT RPAD('a', 0, '') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "RPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "DuckDB supports RPAD for string padding.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123::TEXT, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_96_9",
        "database_name": "duckdb_96_9",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT RPAD('', 0, 'x') AS result; -- RPAD",
        "target_query": "SELECT RPAD('', 0, 'x') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "RPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "DuckDB supports RPAD for string padding.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123::TEXT, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_96_10",
        "database_name": "duckdb_96_10",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT RPAD('', 0, '') AS result; -- RPAD",
        "target_query": "SELECT RPAD('', 0, '') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "RPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "DuckDB supports RPAD for string padding.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123::TEXT, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_96_11",
        "database_name": "duckdb_96_11",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT RPAD('a', -1, 'x'); -- RPAD",
        "target_query": "SELECT RPAD('a', -1, 'x');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "RPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "DuckDB supports RPAD for string padding.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123::TEXT, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_96_12",
        "database_name": "duckdb_96_12",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT RPAD('123456787890', 1, 'x'); -- RPAD",
        "target_query": "SELECT RPAD('123456787890', 1, 'x');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "RPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "DuckDB supports RPAD for string padding.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123::TEXT, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_96_13",
        "database_name": "duckdb_96_13",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT RPAD('a', 5, 'xy'); -- RPAD",
        "target_query": "SELECT RPAD('a', 5, 'xy');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "RPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "DuckDB supports RPAD for string padding.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123::TEXT, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_96_14",
        "database_name": "duckdb_96_14",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT RPAD(\"I LOVE SQL\", 20, \" \"); -- RPAD",
        "target_query": "SELECT RPAD('I LOVE SQL', 20, ' ');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "RPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "DuckDB supports RPAD for string padding.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123::TEXT, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_96_15",
        "database_name": "duckdb_96_15",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT RPAD(\"I LOVE SQL in the morning\", 20, \" \"); -- RPAD",
        "target_query": "SELECT RPAD('I LOVE SQL in the morning', 20, ' ');",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "RPAD"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "DuckDB supports RPAD for string padding.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123::TEXT, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": "duckdb_97_6",
        "database_name": "duckdb_97_6",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "EXPLAIN SELECT * FROM t1 WHERE ISNULL(t1.a IN (SELECT t3.a FROM t1 t3)); -- ISNULL",
        "target_query": "EXPLAIN SELECT * FROM t1 WHERE t1.a IN (SELECT t3.a FROM t1 t3) IS NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ISNULL"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "ISNULL(expr)",
                "description": "Returns 1 if the expression is NULL, otherwise returns 0.",
                "examples": [
                    "SELECT ISNULL(NULL);",
                    "SELECT ISNULL(5 + NULL);",
                    "SELECT IF(ISNULL(score), 'N/A', score) FROM students;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "expr IS NULL",
                "description": "Tests whether the expression evaluates to NULL.",
                "examples": [
                    "SELECT NULL IS NULL;",
                    "SELECT ('abc' || NULL) IS NULL;",
                    "SELECT CASE WHEN status IS NULL THEN 'unknown' ELSE status END FROM orders;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, INTEGER, )\n(b, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_97_7",
        "database_name": "duckdb_97_7",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT * FROM t1 WHERE ISNULL(t1.a IN (SELECT t3.a FROM t1 t3)); -- ISNULL",
        "target_query": "SELECT * FROM t1 WHERE t1.a IN (SELECT t3.a FROM t1 t3) IS NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "ISNULL"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "ISNULL(expr)",
                "description": "Returns 1 if the expression is NULL, otherwise returns 0.",
                "examples": [
                    "SELECT ISNULL(NULL);",
                    "SELECT ISNULL(5 + NULL);",
                    "SELECT IF(ISNULL(score), 'N/A', score) FROM students;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "expr IS NULL",
                "description": "Tests whether the expression evaluates to NULL.",
                "examples": [
                    "SELECT NULL IS NULL;",
                    "SELECT ('abc' || NULL) IS NULL;",
                    "SELECT CASE WHEN status IS NULL THEN 'unknown' ELSE status END FROM orders;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, INTEGER, )\n(b, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_98_4",
        "database_name": "duckdb_98_4",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "EXPLAIN SELECT * FROM t1 WHERE (SELECT b FROM t2 WHERE CAST(UUID() AS CHAR) = CAST(t2.a AS CHAR)) > 0; -- UUID",
        "target_query": "EXPLAIN SELECT * FROM t1 WHERE (SELECT b FROM t2 WHERE CAST(uuid() AS TEXT) = CAST(t2.a AS TEXT) ) > 0;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "UUID"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UUID()",
                "description": "In MySQL, the UUID() function generates a unique 128-bit identifier, typically represented as a string containing numbers and letters, in the standard UUID format.",
                "examples": [
                    "SELECT UUID();",
                    "SELECT CONCAT(UUID(), 'some_random_string');",
                    "SELECT UPPER(UUID());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "uuid()",
                "description": "DuckDB supports the uuid() function, which generates a unique 128-bit identifier in the same format as MySQL's UUID() function.",
                "examples": [
                    "SELECT uuid();",
                    "SELECT CONCAT(uuid(), 'some_random_string');"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(x, int, )\n(y, int, )\n",
            "Table: `t2`\nColumns:\n(a, int, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(x, INTEGER, )\n(y, INTEGER, )\n",
            "Table: `t2`\nColumns:\n(a, INTEGER, )\n(b, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_98_14",
        "database_name": "duckdb_98_14",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1 ; -- COALESCE",
        "target_query": "SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1 ;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "COALESCE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
                "description": "Returns the first non-NULL value, or merges table partitions.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
                    "ALTER TABLE t1 COALESCE PARTITION 2;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...)",
                "description": "DuckDB supports COALESCE for NULL handling.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n",
            "Table: `t3`\nColumns:\n(a, int, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, INTEGER, )\n",
            "Table: `t3`\nColumns:\n(a, INTEGER, )\n(b, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_98_15",
        "database_name": "duckdb_98_15",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "EXPLAIN SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1 ; -- COALESCE",
        "target_query": "EXPLAIN SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1 ;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "COALESCE"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
                "description": "Returns the first non-NULL value, or merges table partitions.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
                    "ALTER TABLE t1 COALESCE PARTITION 2;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...)",
                "description": "DuckDB supports COALESCE for NULL handling.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n",
            "Table: `t3`\nColumns:\n(a, int, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, INTEGER, )\n",
            "Table: `t3`\nColumns:\n(a, INTEGER, )\n(b, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_98_16",
        "database_name": "duckdb_98_16",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT (SELECT IFNULL(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1 ; -- IFNULL",
        "target_query": "SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1 ;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IFNULL"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IFNULL(expr1, expr2)",
                "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
                "examples": [
                    "SELECT IFNULL(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2)",
                "description": "DuckDB also uses COALESCE to return the first non-NULL argument, which is functionally the same as IFNULL in MySQL.",
                "examples": [
                    "SELECT COALESCE(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n",
            "Table: `t3`\nColumns:\n(a, int, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, INTEGER, )\n",
            "Table: `t3`\nColumns:\n(a, INTEGER, )\n(b, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_98_17",
        "database_name": "duckdb_98_17",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "EXPLAIN SELECT (SELECT IFNULL(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1 ; -- IFNULL",
        "target_query": "EXPLAIN SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1 ;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "IFNULL"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IFNULL(expr1, expr2)",
                "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
                "examples": [
                    "SELECT IFNULL(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2)",
                "description": "DuckDB also uses COALESCE to return the first non-NULL argument, which is functionally the same as IFNULL in MySQL.",
                "examples": [
                    "SELECT COALESCE(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `t1`\nColumns:\n(a, int, )\n",
            "Table: `t3`\nColumns:\n(a, int, )\n(b, int, )\n"
        ],
        "target_related_schemas": [
            "Table: `t1`\nColumns:\n(a, INTEGER, )\n",
            "Table: `t3`\nColumns:\n(a, INTEGER, )\n(b, INTEGER, )\n"
        ]
    },
    {
        "sql_id": "duckdb_99_6",
        "database_name": "duckdb_99_6",
        "source_dialect": "mysql",
        "target_dialect": "duckdb",
        "source_query": "SELECT TRIM(f1), COUNT(*) FROM table_varchar_pad_space GROUP BY f1; -- TRIM, COUNT",
        "target_query": "SELECT TRIM(f1), COUNT(*) FROM table_varchar_pad_space GROUP BY f1;",
        "semantic_equivalent_type": "exact_equivalence",
        "dialect_tokens": [
            "TRIM",
            "COUNT"
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
                "description": "The TRIM function removes unwanted characters from the beginning and/or end of a string. If no character is specified, it removes spaces by default. You can specify 'BOTH', 'LEADING', or 'TRAILING' to trim characters from both ends, the start, or the end, respectively.",
                "examples": [
                    "SELECT TRIM('x' FROM 'xxabcx');",
                    "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
                    "SELECT TRIM(LEADING '0' FROM '000123');"
                ]
            },
            {
                "expression": "COUNT()",
                "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
                "examples": [
                    "EXPLAIN FORMAT=TREE SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
                    "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
                    "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
                "description": "DuckDB's TRIM function is identical to MySQL's, removing unwanted characters from the beginning or end of a string, or from both ends if specified.",
                "examples": [
                    "SELECT TRIM('x' FROM 'xxabcx');",
                    "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
                    "SELECT TRIM(LEADING '0' FROM '000123');"
                ]
            },
            {
                "expression": "COUNT()",
                "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
                "examples": [
                    "EXPLAIN SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
                    "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
                    "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
                ]
            }
        ],
        "source_related_schemas": [
            "Table: `table_varchar_pad_space`\nColumns:\n(f1, varchar(20), )\n"
        ],
        "target_related_schemas": [
            "Table: `table_varchar_pad_space`\nColumns:\n(f1, VARCHAR, )\n"
        ]
    }
]